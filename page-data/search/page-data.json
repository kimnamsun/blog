{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"심심해서 짤 생성기를 만들어보았다. 나한테 제일 익숙한 react로 할까 했으나 최근에 vue를 하게 되었기 때문에 vue를 사용해보기로 했다. react 의 cra처럼 vue도 간단하게 프로젝트를 생성해주는 명령어가 있다. 근데 우선 vue-cli 가 깔려있어야함 vue-cli 설치 project 생성 sass 설치, element-ui 설치 기본 플로…","fields":{"slug":"/contents/posts/2023-08-27/"},"frontmatter":{"date":"August 27, 2023","title":"동물의 숲 짤 생성기를 만들었다"},"rawMarkdownBody":"\n> 심심해서 짤 생성기를 만들어보았다.  \n> 나한테 제일 익숙한 react로 할까 했으나 최근에 vue를 하게 되었기 때문에 vue를 사용해보기로 했다.\n\nreact 의 cra처럼 vue도 간단하게 프로젝트를 생성해주는 명령어가 있다.\n\n근데 우선 [vue-cli](https://cli.vuejs.org/#getting-started) 가 깔려있어야함\n\nvue-cli 설치\n\n```tsx\nnpm install -g @vue/cli\n# OR\nyarn global add @vue/cli\n```\n\nproject 생성\n\n```tsx\nvue create my-project\n# OR\nvue ui\n```\n\nsass 설치, element-ui 설치\n\n### 기본 플로우\n\n간단한 사이드프로젝트라 그렇게 복잡하지는 않다.\n\n![](https://velog.velcdn.com/images/nsunny0908/post/e6dfb499-bcb1-449a-818b-0efd7d5b856e/image.jpg)\n\n1. 사용자가 input에 값을 입력하면, 입력할 때마다 onValueChanged 함수가 실행된다.\n   - onValueChange 함수는 줄바꿈의 수와, maxLength를 체크해 입력을 제한하는 역할을 한다.\n2. drawImage 함수는 이미지가 없으면 이미지를 로드하고, 이미지가 있으면 drawCanvasText를 실행한다.\n\n   3.drawCanvasText 함수는 inputs을 순회하며 공통 스타일에 대한 처리를 하고, type에 따라 updateCanvasText 함수를 실행한다.\n\n### updateCanvasText\n\n```javascript\n\nupdateCanvasNameText(text) {\n  const style = this.getNameInput.style;\n\n  const { canvas } = this.$refs;\n  const ctx = canvas.getContext('2d');\n\n  const lines = text.split('\\n');\n  // 행 간격\n  const lineHeight = this.commonStyle.fontSize * 1.5;\n  // x 좌표값 조정\n  const x = 165;\n  // y 좌표값 조정\n  const y = 75;\n\n   // 회전 각도 (라디안)\n  const angle = -Math.PI / 20;\n\n  // 현재 컨텍스트 설정 저장\n  ctx.save();\n  // 회전 중심 좌표 설정\n  ctx.translate(x, y);\n  // 지정한 각도만큼 회전\n  ctx.rotate(angle);\n  ctx.fillStyle = style.fontColor;\n\n  lines.forEach((line, index) => {\n    const yCoord = index * lineHeight;\n    // 회전한 각도에 따라 텍스트 그리기\n    ctx.fillText(line, 0, yCoord);\n  });\n\n  // 이전 컨텍스트 설정 복구\n  ctx.restore();\n},\n\nupdateCanvasContentsText(text) {\n  const style = this.getContentsInput.style;\n\n  const { canvas } = this.$refs;\n  const ctx = canvas.getContext('2d');\n\n  const lines = text.split('\\n');\n  // 행 간격\n  const lineHeight = this.commonStyle.fontSize * 1.5;\n  // 텍스트 전체 높이\n  const totalTextHeight = lines.length * lineHeight;\n    // 이미지 위에 텍스트를 그리기 위해 조정\n  const yStartPosition =\n    (canvas.height - totalTextHeight) / 2 + this.commonStyle.fontSize / 2;\n\n  lines.forEach((line, index) => {\n    const y = yStartPosition + index * lineHeight;\n\n    ctx.fillStyle = style.fontColor;\n    ctx.fillText(line, canvas.width / 2, y);\n  });\n},\n\n```\n\n- name부분은 x, y 좌표값을 임의로 조정하고, 회전을 주어서 원하는 위치에 텍스트를 그릴 수 있도록 했다.\n\n- contents 부분은 텍스트를 그릴 때, canvas의 높이를 기반으로 텍스트를 중앙에 정렬하기 위해 수직 위치를 계산해서 그릴 수 있도록 했다.\n\n- canvas에서 text를 스타일링할 때 fillStyle과 strokeStyle을 나눠서 사용할 수 있다. 나는 strokeStyle은 필요하지 않아서 fillStyle만 사용했다.\n\n  - fillStyle은 텍스트의 색상을 지정한다.\n  - strokeStyle은 텍스트의 테두리 색상을 지정한다.\n\n### 리팩토링하기\n\n1. 공통스타일 분리하기\n\n기존에는 font 관련 설정, 정렬 관련 로직이 updateCanvasNameText, updateCanvasContentsText 함수에 각각 중복으로 존재했다.\n\ninputs style에 중복으로 존재하는 부분을 commonStyle로 분리했다.\n\n```javascript\ndata() {\n    return {\n      commonStyle: {\n        fontFamily: 'NanumGothic',\n        fontSize: 30,\n        fontWeight: 'bold',\n        textBorder: 'none',\n      },\n      inputs: [\n        {\n          id: 1,\n          type: 'name',\n          label: '이름',\n          text: '',\n          style: {\n            ...this.commonStyle,\n            fontColor: '#683617',\n          },\n          maxLength: 3,\n        },\n        {\n          id: 2,\n          type: 'contents',\n          label: '내용',\n          text: '',\n          style: {\n            ...this.commonStyle,\n            fontColor: '#827255',\n          },\n          maxLength: 30,\n        },\n      ],\n    };\n  },\n```\n\n```javascript\ndrawCanvasText() {\n  this.inputs.forEach(({ type, text }) => {\n    if (!text) {\n      return;\n    }\n\n    const { canvas } = this.$refs;\n    const ctx = canvas.getContext('2d');\n\n\n// 공통 스타일 설정 부분\n    ctx.font = `${this.commonStyle.fontWeight} ${this.commonStyle.fontSize}px ${this.commonStyle.fontFamily}`;\n\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.textBorder = this.commonStyle.textBorder;\n\n    if (type === 'name') {\n      this.updateCanvasNameText(text);\n      return;\n    }\n\n    if (type === 'contents') {\n      this.updateCanvasContentsText(text);\n      return;\n    }\n  });\n},\n```\n\n2. 이미지가 있을 때는 그냥 바로 그려주기\n\n```javascript\n\nonValueChanged(type, value) {\n  const input = this.inputs.find((input) => input.type === type);\n\n  if (!input) {\n    return;\n  }\n\n  // 줄 바꿈 문자('\\n')의 개수를 세기 위한 정규 표현식 사용\n  const lineBreakCount = (value.match(/\\n/g) || []).length;\n\n  // 만약 줄 바꿈 문자가 4개 이상이면, 더 이상 입력을 허용하지 않음\n  if (input.type === 'contents' && lineBreakCount >= 4) {\n    return;\n  }\n\n  // maxLength를 초과하는 경우, maxLength까지만 입력값을 자름\n  if (value.length > input.maxLength) {\n    value = value.slice(0, input.maxLength);\n  }\n\n  input.text = value;\n\n  this.drawImage();\n},\n\ndrawImage() {\n  const { canvas } = this.$refs;\n  const ctx = canvas.getContext('2d');\n\n  const img = new Image();\n  img.src = require('@/assets/image2.png');\n\n  img.onload = () => {\n    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n\n    this.inputs.forEach(({ type, text }) => {\n      if (!text) {\n        return;\n      }\n\n      if (type === 'name') {\n        this.updateCanvasNameText(text);\n        return;\n      }\n\n      if (type === 'contents') {\n        this.updateCanvasContentsText(text);\n        return;\n      }\n    });\n  };\n},\n```\n\n기존에는 onValueChanged 함수를 호출할 때 마다 이미지를 계속 로드하고 있는데, 이미지가 이미 있을 경우에는 그냥 바로 그려주는 것으로 리팩토링했다.\n\n```javascript\n\ndrawImage() {\n  const { canvas } = this.$refs;\n  const ctx = canvas.getContext('2d');\n\n  if (!this.img) {\n    // 이미지가 없으면 로드\n    this.img = new Image();\n    this.img.src = this.getImage;\n\n    this.img.onload = () => {\n      // 이미지가 로드되면 그림\n      ctx.drawImage(this.img, 0, 0, canvas.width, canvas.height);\n      this.drawCanvasText();\n    };\n    return;\n  }\n\n  ctx.drawImage(this.img, 0, 0, canvas.width, canvas.height);\n  this.drawCanvasText();\n},\n```\n\n### 배포\n\n간단하게 netlify로 배포까지 완료!\n\n[동물의 숲 짤 생성기 보러가기](https://animal-crossing-maker.netlify.app/)\n"},{"excerpt":"어떤 사람들은 제목을 보고 으.. 싫다 라고 생각할 수도 있다. 그치만 언제나 하고 싶은것만 할 수는 없는게 회사이기 때문에, 내가 남의 코드를 받아서 유지보수하기 위해 어떤 과정들을 거쳤는지 기록해보려고 한다. 0. 익숙하지 않은 프레임워크를 학습하기 나는 계속 리액트만을 해오다가 얼마전, Vue.js 로 된 프로젝트를 기능 개발 및 유지보수하게 되었다…","fields":{"slug":"/contents/posts/2023-08-25/"},"frontmatter":{"date":"August 25, 2023","title":"처음 남의 코드를 받으면 뭘 해야할까?"},"rawMarkdownBody":"\n> 어떤 사람들은 제목을 보고 으.. 싫다 라고 생각할 수도 있다.  \n> 그치만 언제나 하고 싶은것만 할 수는 없는게 회사이기 때문에, 내가 남의 코드를 받아서 유지보수하기 위해 어떤 과정들을 거쳤는지 기록해보려고 한다.\n\n### 0. 익숙하지 않은 프레임워크를 학습하기\n\n나는 계속 리액트만을 해오다가 얼마전, Vue.js 로 된 프로젝트를 기능 개발 및 유지보수하게 되었다.\n\nVue.js는 처음 접해봤기 때문에, 다음과 같은 과정을 거쳐 익숙해지려 노력했다.\n\n- **공식문서 읽기**\n\n  사실, 프레임워크가 다르기는 해도 기본적으로 javascript 위에서 동작하고 **\"상태가 변경되면 DOM을 업데이트 한다\"** 는 큰 패러다임은 바뀌지 않으므로 엄청난 어려움은 없었지만, 라이브러리(리액트) 프레임워크(뷰)의 차이점에서 조금 당황하기는 했다.\n\n- **비교분석**\n  리액트와 Vue.js의 차이점을 비교 분석하면서 이해하려고 노력했다. 리액트에서 익숙한 개념을 Vue.js에서 어떻게 구현하는지에 주목했다.  \n  리액트에서는 손수 다 작업해야하는 부분을, 뷰에서는 이미 프레임워크에서 해주기 때문에 사용만 하면 된다던지.. 그래서 디버깅이 쉽지는 않았다.  \n  아 이과정에서 IDE도 vscode에서 intelliJ로 바꿨다. ~~인텔리제이 짱 역시 유료인 이유가 있다~~\n\n### 1. 구조 파악하기\n\n가장 큰 뼈대를 알아야 디테일한 부분을 봤을때 이해가 쉽다. 처음엔 폴더의 구조를 살펴봤다.\n\n- **폴더 구조 분석**\n  프로젝트의 폴더 구조를 살펴보고, Vue.js에서 vue 인스턴스를 생성하는 main.js와 루트 컴포넌트인 App.vue 를 시작으로 분석을 시작해나갔다.  \n  ![Untitled2.png](https://velog.velcdn.com/images/nsunny0908/post/5ad97c3c-1cef-44ee-8cc1-f0bee7e8ab48/image.png)\n\n- **페이지 구조 분석**\n\n다음은 페이지 단위로 구조를 분석하기 시작했다. 프로젝트의 특성 상 비슷한 구조의 페이지가 반복되었으므로, 각 페이지 마다 어떤 메뉴 타입을 가지고 있는지 리스트업했다.  \n![](https://velog.velcdn.com/images/nsunny0908/post/91db7801-1900-4d85-8b45-9fcb834fbf97/image.png)\n\n다음은 어떤 페이지인지에 대한 간략한 설명과, UI, 기본 구조, API call 리스트를 정리했다.\n\n![](https://velog.velcdn.com/images/nsunny0908/post/da02786d-c2f0-430c-8413-410eea91508e/image.png)\n![](https://velog.velcdn.com/images/nsunny0908/post/b5f28bcf-1b98-4fac-8816-88ceb675f356/image.png)\n![](https://velog.velcdn.com/images/nsunny0908/post/d5f1e24f-3727-434a-a0a9-b22b497f91a2/image.png)\n\n### 2. 핵심 플로우 파악하기\n\n프로젝트 마다 ‘핵심 비즈니스 로직’이라는 것이 존재한다. 보통 처음 남의 코드를 열어봤을때 이런 핵심 비즈니스 로직을 완벽하게 파악하는 것은 어렵다.\n\n때문에 도식화를 하거나, 플로우를 정리하는 것이 도움이 된다.\n\n나는 결제 관련 플로우를 이해하는데에 미로를 사용했다.\n\n![](https://velog.velcdn.com/images/nsunny0908/post/6b5bbf81-6d01-45fc-b8fa-4dae4ad6be80/image.jpg)\n![](https://velog.velcdn.com/images/nsunny0908/post/03bd762b-5f69-4fa1-8622-a5b75c5a99aa/image.jpg)\n![](https://velog.velcdn.com/images/nsunny0908/post/280c0fd0-2f6f-4155-a481-cd9b61203c05/image.jpg)\n\n### 3. 사소한 문제를 수정해보기\n\n중요한 테스크를 진행하기 이전에 아주 사소한 문제를 수정해보는 것은, 해당 프로젝트를 내가 잘 유지보수할 수 있다는 자신감을 키워주고 실제적인 문제를 해결함으로써 코드의 동작 방식을 이해하고 추후에 개선이 필요한 부분을 인지하는 데 도움을 준다.\n\n실제로 **버튼 수정하기, 테이블 UI 수정하기** 등과 같은 사용자가 불편하다고 여겨 QA가 들어왔던 이슈들을 해결하면서 어떤 부분에 있어 사용자가 불편함을 느끼는지와 앞으로 개선해야할 것들을 알 수 있었다.\n\n### 4. 개선 사항 찾기\n\n개선사항은 다양하게 나타날 수 있다.  \n사용자로서 불편함을 경험하는 측면이나, 프로젝트를 유지보수하는 개발자의 입장에서 개선이 필요한 부분들이 있을 수 있다.  \n중요한 점은 이러한 개선사항을 주체적으로 찾아내는 것이 해당 프로젝트를 더 잘 이해하고 발전시키는 데 도움을 준다는 것이다.\n"},{"excerpt":"문제상황 vue template 내에서 을 이용해 처리해야하는 부분이 있었다. 아래 처럼 코드를 작성했더니 에러가 떴다. Alt text 원인 찾아보니 vue template에서 global scope variables를 사용할 수 없다는게 결론이였다.. https://stackoverflow.com/questions/55323010/why-cant-us…","fields":{"slug":"/contents/posts/2023-08-13/"},"frontmatter":{"date":"August 13, 2023","title":"why can’t use window in vue template?"},"rawMarkdownBody":"\n## 문제상황\n\n> vue template 내에서 `window.location.pathName`을 이용해 처리해야하는 부분이 있었다.  \n> 아래 처럼 코드를 작성했더니 에러가 떴다.\n\n```javascript\n<h1 v-if=\"window.location.pathName\">Title</h1>\n```\n\n![Alt text](image.png)\n\n## 원인\n\n찾아보니 vue template에서 global scope variables를 사용할 수 없다는게 결론이였다..\n\nhttps://stackoverflow.com/questions/55323010/why-cant-use-window-in-vue-template\n\n## 해결\n\n위의 링크에서 제시하는 해결법은 vuex를 사용한다던가, Mixins을 사용한다는 등의 몇가지 방법이 있었는데,  \n나는 그 중`computed`를 이용해서 해결했다.\n\n```javascript\ncomputed: {\n    getPathName() {\n      return window.location.pathname;\n    },\n},\n```\n\n```javascript\n<h1 v-if=\"getPathName을 이용한 조건 작성\">Title</h1>\n```\n"},{"excerpt":"문제상황 이것은 vuejs 공식페이지에 들어가자마자 보이는 문구이다. 그렇다.. vue를 하게 되었다.. (3로 마이그레이션 언제하지..) 자세한 기능이나 이런것들은 따로 작성하지 않을 것이다. 공식문서가 훨씬 잘나와있음. 내가 코드분석하면서 이해한 것 위주로 작성된 것임. (내가 보려고 작성했단 뜻) main.js 진입점 new Vue : Vue 인스턴…","fields":{"slug":"/contents/posts/2023-08-05/"},"frontmatter":{"date":"August 05, 2023","title":"The Progressive JavaScript Framework"},"rawMarkdownBody":"\n## 문제상황\n\n> 이것은 vuejs 공식페이지에 들어가자마자 보이는 문구이다.  \n> 그렇다.. vue를 하게 되었다.. (~~3로 마이그레이션 언제하지..~~)  \n> 자세한 기능이나 이런것들은 따로 작성하지 않을 것이다. 공식문서가 훨씬 잘나와있음.  \n> 내가 코드분석하면서 이해한 것 위주로 작성된 것임. (내가 보려고 작성했단 뜻)\n\n## main.js\n\n- 진입점\n- new Vue : Vue 인스턴스 생성\n- `el: \"#app\"`: Vue 인스턴스가 마운트될 HTML 요소를 지정.  \n  \"#app\"은 HTML 문서 내에서 id가 \"app\"인 요소를 찾아 사용.\n- `router`: Vue Router 인스턴스를 사용하여 라우팅 기능을 추가\n- `render: (h) => h(App)`: 애플리케이션의 루트 컴포넌트인 `App` 컴포넌트를 렌더링.  \n  `(h) => h(App)`는 렌더링 함수를 나타내며, **`h`**는 createElement 함수를 의미한다.\n\n## App.vue\n\n컴포넌트에서 `data() {}` 형태로 쓰는 이유  \n-> 컴포넌트를 여러개 썼을때 데이터가 공유되는 현상을 막기 위해 항상 새로운 객체를 생성해 return 하는 메서드를 지정해줌\n\n- `[created()](https://ko.vuejs.org/api/options-lifecycle.html#created)`: 컴포넌트가 생성되었을 때 실행되는 라이프사이클 훅.\n- `[mounted()](https://ko.vuejs.org/api/options-lifecycle.html#mounted)`: 컴포넌트가 마운트된 후에 실행되는 라이프사이클 훅.\n- 참고: https://ko.vuejs.org/api/options-lifecycle.html\n\n- `@*close*=\"eventName\"`\n  - 사용자가 직접 정의한 커스텀 이벤트\n  - 커스텀 이벤트를 사용하여 부모 컴포넌트와 통신하고 상호작용할 수 있다.\n  - `@close` 이벤트는 부모 컴포넌트에서 발생, 해당 컴포넌트 내부에서 닫기 동작이 수행될 때 이벤트를 발생시킨다.  \n    이 이벤트는 부모 컴포넌트에서 `@close` 속성을 사용하여 해당 이벤트에 대한 핸들러를 등록할 수 있다.\n  - 부모 내부에서 `@click=\"$emit('close')\"` 이런식으로 이벤트를 발생시킨다.\n\n### computed\n\n- 템플릿 코드 대신 사용할 수 있다.\n- data 속성이 변했을 때 이를 감지하고 자동으로 다시 연산해준다.\n- 인자를 받지 않는다.\n- HTTP 통신과 같이 브라우저 리소스가 많이 필요한 코드들은 watch나 methods에 넣는 것이 적합하다.\n\n### watch\n\n- 특정 데이터나 표현식의 변화를 감지하고, 그에 따라 특정 동작을 수행하는 역할\n\n### computed vs watch\n\n- watch 속성은 감시할 데이터를 지정하고 데이터가 바뀌면 함수를 실행하는 방식 → 명령형 프로그래밍\n- computed 속성은 계산해야하는 목표 데이터를 정의하는 방식 → 선언형 프로그래밍\n\n### $emit\n\n- 컴포넌트 내에서 커스텀 이벤트를 발생시킬 수 있다.\n- `$emit('close')`는 `close`라는 이름의 커스텀 이벤트를 발생시키는 것을 의미한다.\n\n### slot\n\n- 부모가 되는 컴포넌트에서 자식 컴포넌트의 템플릿의 일부를 삽입하는 기능\n\n- 부모 component\n\n```vue\n<template>\n  <div class=\"home\">\n    <MyCom></MyCom>\n    <MyCom>\n      <template v-slot:name>aila</template>\n    </MyCom>\n    <MyCom>\n      <template v-slot:age>999</template>\n    </MyCom>\n  </div>\n</template>\n<script>\nimport MyCom from \"@/components/MyCom.vue\"\nexport default {\n  components: {\n    MyCom,\n  },\n}\n</script>\n```\n\nv-bind - `:`\n\nv-on - `@`\n\nv-slot - `#`\n\n으로 축약가능\n\n- 자식 component\n\n```vue\n<template>\n  <div class=\"mycom\">\n    <p>name:<slot name=\"name\">namsun</slot></p>\n    <p>address:<slot name=\"age\">99</slot></p>\n  </div>\n</template>\n```\n"},{"excerpt":"문제상황 모달을 열 때, member 정보를 보내줘서 신분증 이미지를 내려주는 api가 연동되어있던 부분에서 오류가 났다. 기존 다른 api의 경우, 이미지의 url을 response로 내려주었는데 해당 api는 를 내려주었다. 스웨거로 요청할 때는 정상적으로 이미지가 나오는데 흠? 삽질1 내려온 이미지를 blob 객체로 변환해서 imageUrl을 생성해…","fields":{"slug":"/contents/posts/2023-07-05/"},"frontmatter":{"date":"July 05, 2023","title":"get image api 오류 트러블 슈팅"},"rawMarkdownBody":"\n## 문제상황\n\n> 모달을 열 때, member 정보를 보내줘서 신분증 이미지를 내려주는 api가 연동되어있던 부분에서 오류가 났다.  \n> 기존 다른 api의 경우, 이미지의 url을 response로 내려주었는데 해당 api는 `이미지 그 자체`를 내려주었다.  \n> 스웨거로 요청할 때는 정상적으로 이미지가 나오는데  \n> 흠?\n\n## 삽질1\n\n내려온 이미지를 blob 객체로 변환해서 imageUrl을 생성해보았다. → url을 만드는 과정에서 blob url이 달라졌다.\n\n```\nconst imageUrl = window.URL.createObjectURL(new Blob([response.data]));\n```\n\n- 스웨거에서는 image url이\n  `blob:https://{link}/{memberId}`\n  이렇게 나오는데, 로컬에서 테스트할때는 다르게 나왔다.\n\n## 삽질2\n\n1. response type을 `arraybuffer`로 설정했다.\n\n```ts\ngetImage: (params: GetImageParams) => {\n    return requester.get<GetImageResponse>(\n      `${BASE_URL}/image`,\n      {\n        params,\n        responseType: 'arraybuffer',\n      },\n    );\n  },\n```\n\n2. 그런데 api를 호출하는 쪽에서 blob객체를 url로 변환하려고 하니까 자꾸 타입 안맞다고 에러가 떴다.\n\n### 원인\n\n이미지 생성하는데 시간이 좀 걸렸는데 생성 전까지는 이미지가 `undefined`이기 때문에 api 호출하는 쪽에서 처음에 undefined로 뜨는걸 계속 변환하려고 하니까 에러가 떴던 거였다.\n\n### 해결\n\napi hook 안에서 `async await` 걸고 안에서 변환해서 변환한 url link를 return해주니까 해결!\n\n```ts\nconst useGetImage = (params: GetImageParams) => {\n  return useQuery(\n    queryKey,\n    async () =>\n      await Api.getImage(params).then((response) => {\n        const blob = new Blob([response.data], { type: \"image/png\" })\n        const imageUrl = URL.createObjectURL(blob)\n        return imageUrl\n      })\n  )\n}\n```\n\n### 리팩토링\n\n```ts\nconst useGetImage = (params: Partial<GetImageParams>, enabled?: boolean) => {\n  return useQuery(\n    queryKey,\n    async () => {\n      const response = await Api.getImage(params)\n\n      const blob = new Blob([response.data], { type: \"image/png\" })\n      const imageUrl = URL.createObjectURL(blob)\n\n      return imageUrl\n    },\n    {\n      enabled: enabled ?? !!(params.fileName && params.key),\n\n      onError: async (error: AxiosError<any>) => {\n        snackbar.error({\n          title: \"이미지 불러오기 실패\",\n          content:\n            JSON.parse(await error?.response?.data?.text()).status.message ||\n            \"이미지를 불러오지 못했습니다.\",\n        })\n      },\n    }\n  )\n}\n```\n"},{"excerpt":"👐  스무살 아님 어떻게 지나갔는지 모를 1년이 지나갔다. 올 한 해는 어떻게 지냈는지 내가 기억하기 위해서 작성하는 회고! 👩🏻‍💻 회사 & 업무 여름쯤부터 개발팀 위에 개발실이 생기고, 팀의 R&R이 정리되면서 팀이 바뀌었다. 레거시 프로젝트를 새로운 프로젝트로 처음부터 다시 만드는 프로젝트였는데 패기롭게 손들고 지원했다. 🙋🏻‍♀️  그래서 통합 어드민 업무를 …","fields":{"slug":"/contents/posts/2022-12-31/"},"frontmatter":{"date":"December 31, 2022","title":"2022년 회고"},"rawMarkdownBody":"\n## 👐\n\n![](https://velog.velcdn.com/images/nsunny0908/post/e951f132-82d9-4f8d-aaad-e15313f47cfe/image.png)\n\n~~스무살 아님~~\n\n어떻게 지나갔는지 모를 1년이 지나갔다.  \n올 한 해는 어떻게 지냈는지 내가 기억하기 위해서 작성하는 회고!\n\n## 👩🏻‍💻 회사 & 업무\n\n여름쯤부터 개발팀 위에 개발실이 생기고, 팀의 R&R이 정리되면서 팀이 바뀌었다.  \n레거시 프로젝트를 새로운 프로젝트로 처음부터 다시 만드는 프로젝트였는데 패기롭게 손들고 지원했다. 🙋🏻‍♀️\n\n![](https://velog.velcdn.com/images/nsunny0908/post/7e8dc403-02d0-450d-82de-5869e4d8dacb/image.png)\n\n그래서 통합 어드민 업무를 하던 팀에서 새 프로젝트를 맡은 팀으로 팀이 변경되었다.  \n또 일주일에 1~2번만 출근하고 풀재택을 하게 되었다.  \n처음에는 재택할 때 컨디션 관리가 정말 쉽지 않았다.  \n일과 생활의 구분이 명확하지 않아서 힘들었고 (그렇다고 집에서 계속 일만 한 것도 아니였음ㅋㅋㅋ)  \n초반에는 오히려 재택할 때 컨디션이 떨어졌었다. 🥲  \n이제는 밥 먹고 잠깐 집 앞에 산책하러 다녀오기도 하고, 중간중간 환기가 필요할 때 폼롤러로 스트레칭해주기도 한다.  \n역시 사람은 적응의 동물.  \n디폴트가 재택근무로 바뀌고 나서 고민했던 것은 온라인으로 어떻게 효과적으로 커뮤니케이션을 해야 할지에 대한 것이었다.\n아무래도 온라인으로 소통하다 보면 내가 전달하고자 하는 의도와 다르게 전달된 가능성이 있고 말로 가볍게 물어볼 것들은 괜히 부담스러워서 물어보기가 꺼려진다.  \n사실 아직도 뭐가 베스트인지에 대한 해답을 완벽하게 찾은 것 같진 않지만 내가 찾은 방법은 그냥 말을 많이 하는 것이다.  \n쓸데없는 말을 많이 하자는 게 아니라 너무 많은 시간을 이 말을 할까 말까에 대한 생각으로 채우지 말고 그냥 말하기로 했다.\n말이 어렵다면, 노션이나 미로 등의 툴을 사용하는 것도 좋을 것 같다.  \n아직 미로 쓰는 게 어색하지만 많이 써봐야지.  \n개발자는 개발 외에도 잘해야 하는 게 많다는 걸 깨닫게 되는 요즘.  \n또 연말에 평가 시즌이 되면서 느꼈던 건, '하는 것'도 중요하지만 `했던 것을 어떻게 보여주는지` 도 중요하다는 점이었다.  \n막상 내가 1년 동안 뭘 했는지 적으려니까 막막하기도 하고, 그때 잘 적어둘 걸 하는 아쉬움이 생겼다.  \n앞으론 한 달마다 간단하게 뭘 했는지와 어떤 것을 고민했는지를 적어두면 좋을 것 같단 생각이 들었다. 🤓\n\n## 📙 프로젝트, 스터디\n\n프로젝트를 하나 진행했다.  \n프로젝트나 스터디를 구하는 플랫폼을 만드는 것이었는데, 사정상, 완성하지는 못했지만 공통 컴포넌트를 만들어 디자인 시스템을 구축해보았다.  \n열정적인 분들과 프로젝트 외적으로도 개발 이야기를 많이 할 수 있어서 재밌었고, 유익했던 스터디.\n\n> 모여 디자인 시스템  \n> https://justcodeitstudy.github.io/moyeo-design-system/?path=/story/components-accordion--default\n\n## 💪🏻 건강\n\n10월에 코로나에 걸렸다..나는 안 걸릴 줄 알았지.  \n생각보다 크게 아프기도 했고, 격리 이후에도 감기가 오래가고 면역력이 떨어지는 느낌을 받았다.  \n영양제 챙겨 먹고 운동도 꾸준히 하면서 건강관리를 더 열심히 해야겠다. 🤒  \n나는 살기 위해 운동을 하는 타입인데, 오랫동안 해오던 헬스와 필라테스가 어느 순간 재미가 없어졌다.  \n무언가를 아예 모르는 상태에서 배워나가는 즐거움이 있기 때문에 내가 못 하는 수영을 배워보기로 했다.  \n정말 운동능력이 0에 수렴하는지, 배운 지 세달된 지금도 자유형을 잘 못하지만, 꾸준히 하면 언젠가는 나도 리조트 수영장에서 혼자 자유롭게 헤엄칠 수 있겠지 😌\n![](https://velog.velcdn.com/images/nsunny0908/post/95c3ce6a-95a9-42dd-b6d5-96cf31d83ac6/image.png)\n\n## 🛫 여행\n\n올해 다녀온 여행\n\n![](https://velog.velcdn.com/images/nsunny0908/post/0d5f5bdc-e53f-4e58-aeb8-d49a40a27a9e/image.jpg)\n\n부산\n\n![](https://velog.velcdn.com/images/nsunny0908/post/a9526d3c-5c2c-42d6-a8f9-8cd6c6c7ec91/image.JPG)\n\n세부\n\n![](https://velog.velcdn.com/images/nsunny0908/post/579d9f32-e093-40fc-9795-26150e7ca9f7/image.jpg)\n\n제주\n\n내가 태어나고 자란 곳에서 떠나 나를 아는 사람이 없는 곳으로 떠나 혼자가 된 기분을 느낄 수 있어서 여행을 좋아한다.  \n2023년에도 여행 많이 다녀야지.\n\n## ✍🏻 기록\n\n블로그 열심히 쓰자고 했는데 작심 몇 달이 되어버렸다.  \n뜸하더라도 꾸준히 써야겠다.  \n12월 되어서는 일기도 쓰기 시작했다.  \n다이어리 꾸미고 이러면 며칠 못 가서 안 쓰게 될 거라는 걸 알아서 그냥 오늘 어떤 일정이 있었고 어떤 생각을 했는지 5~6줄 정도로 간단히 적고 있다.  \n2023년에는 기록을 좀 더 즐길 수 있는 한 해가 되길.\n\n## 👋🏻 welcome 2023\n\n1년 동안 열심히 산 것 같기도 하고 아닌 것 같기도 하다.  \n이런 생각이 든다면 100% 확실히 열심히 산 건 아니라는 뜻이겠지.  \n내년엔 좀 더 덜 긴가민가한 한 해를 살아야지.  \n내 올해 동기부여는 역시나 남들보다 늦었기 때문에 더더 열심히 그리고 잘해야겠다는 의지.  \n아직 결과가 나오지 않아서 적을 순 없지만, 2023년에 준비하고 있는 것도 있기 때문에 열심히 잘, 그렇지만 너무 숨차지는 않게 `#가보자고`\n"},{"excerpt":"문제상황 갑자기 storybook addon이 안보였다. 해결  ..\n넘 간단하지만 까먹을까봐 블로그에 써둠.","fields":{"slug":"/contents/posts/2022-10-06/"},"frontmatter":{"date":"October 06, 2022","title":"storybook addon 안보일때"},"rawMarkdownBody":"\n## 문제상황\n\n갑자기 storybook addon이 안보였다.\n\n## 해결\n\n`localStorage.clear()` ..\n넘 간단하지만 까먹을까봐 블로그에 써둠.\n"},{"excerpt":"문제상황 yarn으로 패키지 설치를 하니까 이런 오류가 떴다.  원인 node 버전이 맞지 않아서였다. node version 14.16.0을 쓰고 있었다.  해결 14.17.0 버전으로 깔아주었다.\n매우 간단 ..","fields":{"slug":"/contents/posts/2022-09-28/"},"frontmatter":{"date":"September 28, 2022","title":"어쩐지 yarn으로 패키지 설치할 때 오류가 났다.."},"rawMarkdownBody":"\n## 문제상황\n\nyarn으로 패키지 설치를 하니까 이런 오류가 떴다.\n\n![](https://velog.velcdn.com/images/nsunny0908/post/f8a5c6cc-ebe5-42b2-9e2b-7050b5ddb2fe/image.png)\n\n## 원인\n\nnode 버전이 맞지 않아서였다.  \nnode version 14.16.0을 쓰고 있었다.\n\n![](https://velog.velcdn.com/images/nsunny0908/post/fe4687cb-46a8-48be-99e4-c3a2a0e2ad21/image.png)\n\n## 해결\n\n14.17.0 버전으로 깔아주었다.\n매우 간단 ..\n\n![](https://velog.velcdn.com/images/nsunny0908/post/c62411e0-9a86-4e9e-a05b-370478720640/image.png)\n"},{"excerpt":"우선 TypeScript의 타입 시스템에 대해 이야기하는게 좋겠다. Soundness의 반대개념인 Unsoundness가 런타임에 문제를 유발할 수 있지만 TypeScript는 일부 불건전한 동작을 허용한다. Soundness 컴파일 타임에 알기 어려운 특정 타입을 안전하게 허용하는 것을 의미한다. 즉 컴파일러가 런타임 시점 값의 타입을 보장할 수 있다는…","fields":{"slug":"/contents/posts/2022-09-24/"},"frontmatter":{"date":"September 24, 2022","title":"TypeScript의 Soundness와 Type Assertion (as 떡칠하지 말자..)"},"rawMarkdownBody":"\n> 우선 TypeScript의 타입 시스템에 대해 이야기하는게 좋겠다.\n\n- Soundness의 반대개념인 Unsoundness가 런타임에 문제를 유발할 수 있지만 TypeScript는 일부 불건전한 동작을 허용한다.\n\n## Soundness\n\n- 컴파일 타임에 알기 어려운 특정 타입을 안전하게 허용하는 것을 의미한다.\n  - 즉 컴파일러가 런타임 시점 값의 타입을 보장할 수 있다는 개념\n  - 모든 JavaScript 코드를 지원하기 위함\n  - 타입스크립트는 변환된 코드가 런타임에 영향을 미치지 않는 것을 목표로 한다.\n\n일부 불건전한 코드에는 `any`도 있을 수 있고, `as`도 있을 수 있겠다.\n\n> Type Assertion에 대한 이야기를 해보자.\n\n## Type Assertion\n\n- 타입 단언\n- 타입 추론에는 어쩔 수 없는 한계가 존재하기 때문에\n  사용자가 타입을 가장 잘 알고 있다는 것을 명시하는 방법\n\n```tsx\nconst num = (\"1000\" as unknown) as number\n```\n\n```tsx\nconst cat = {\n  name: \"moo\",\n  age: 10,\n} as const\n```\n\n![](https://velog.velcdn.com/images/nsunny0908/post/009197fe-1846-4ffb-bc96-8d2cdf7e7a09/image.png)\n\n- 객체의 모든 프로퍼티들이 readonly로 변경된다.\n- 각 프로퍼티의 타입이 할당된 리터럴 값으로 추론된다.\n- 값의 재할당을 막는다.\n- 추론 범위를 좁혀준다.\n  -> 의도치 않은 오류를 없앨 수 있다.\n\n- 하지만 타입캐스팅과는 다르다!\n- 타입 단언은 컴파일단에서만 타입을 변경한다. 런타임에 영향을 주지 않는다.\n- 어쩔 수 없는 경우를 제외하고 **as를 떡칠하는 경우는 `any`를 쓰는 것과 같다.** (any를 떡칠할거면 TypeScript를 쓰지 않는게 더 낫겠지..)\n\n## 내가 어떨때 as를 썼더라..🧐\n\n- ref 달아서 이벤트핸들러 만들때 자주 쓰게 되었던 것 같다.\n- DOM api 조작시에도 많이 사용했던 것 같고?\n\n```ts\nconst div = document.querySelector(\"div\") as HTMLDivElement\n```\n\n## 그렇다면 최대한 쓰지 않으려면 어떻게 해야할까?\n\n- as를 쓰기 전에 TypeScript가 내 코드를 왜 추론하지 못하는지 살펴보자.\n- 타입가드를 이용해 최대한 타입을 좁혀주자.\n- `instanceof`나 `new.target`을 통해 타입가드를 해준다.\n"},{"excerpt":"과거 javascript는 객체에 private한 속성을 만들 수 없었다. 컨밴션을 정해 외부에서 사용하지 않도록 했다.\n(e.g. _언더바가 prefix로 붙으면 외부에서 접근하지 않는다. 하지만 실제론 접근 가능.) 그러나 근본적으로 private한 속성을 만드는 것이 아닌 치명적인 단점이 있다. 근본적으로 접근이 불가능한 private 속성을 만들기…","fields":{"slug":"/contents/posts/2022-09-12/"},"frontmatter":{"date":"September 12, 2022","title":"javascript class와 private 속성"},"rawMarkdownBody":"\n## 과거 javascript는 객체에 private한 속성을 만들 수 없었다.\n\n- 컨밴션을 정해 외부에서 사용하지 않도록 했다.\n  (e.g. \\_언더바가 prefix로 붙으면 외부에서 접근하지 않는다. 하지만 실제론 접근 가능.)\n- 그러나 근본적으로 private한 속성을 만드는 것이 아닌 치명적인 단점이 있다.\n\n```jsx\nfunction SomeConstructor() {\n  this._privateProp = \"dont touch this\"\n  this.publicProp = \"you can touch this\"\n}\n```\n\n## 근본적으로 접근이 불가능한 private 속성을 만들기\n\n- 클로저를 사용한다.\n\n```jsx\nfunction SomeModule() {\n  const privateProp = 'dont touch this';\n  const publicProp = 'you can touch this';\n\n  _doSomethingWithPrivateProp = () => { ... }\n\n  const publicMethod = () => {\n    _doSomethingWithPrivateProp();\n    // ...\n  }\n\n  return {\n    publicProp,\n    publicMethod\n  }\n}\n```\n\n- 효과적으로 데이터와 메서드를 숨기는데 유용하다.\n- 생성자의 인스턴스 별로 private한 속성을 만들어야하는 상황에서는 적절치 않다.\n\n## 드디어 정식으로 private속성을 만들수 있다.\n\n- private와 같은 키워드 대신, prefix로 `#` 를 사용한다.\n- 속성 명 앞에 `#` 이 붙으면 private한 필드로 동작한다.\n- `#` 없이 동작할 수 없다.\n\n```jsx\nclass Human {\n  #age = 10\n}\n\nconst person = new Human()\n```\n\n```jsx\nclass Human {\n  #age = 10\n\n  getAge() {\n    return this.age\n    // Error TS2551: Property 'age' does not exist on type 'Human'.\n    // Did you mean '#age'?\n  }\n}\n```\n\n- 반드시 선언을 통해서만 만들 수 있고 동적으로 추가할 수 없다.\n- 메서드를 선언할때는 사용할 수 없다.\n- 외부의 게터를 통해 private 속성에 접근할 수 있다.\n\n```jsx\nclass Human {\n  #age = 10\n\n  getAge() {\n    return this.#age\n  }\n}\n\nconst person = new Human()\n\nconsole.log(person.getAge()) // 10\n```\n\n## **모든 Private 필드는 소속된 클래스에 고유한 스코프를 갖는다.**\n\n```jsx\nclass Human {\n  age = 10\n\n  getAge() {\n    return this.age\n  }\n}\n\nclass Person extends Human {\n  age = 20\n\n  getFakeAge() {\n    return this.age\n  }\n}\n\nconst p = new Person()\nconsole.log(p.getAge())\nconsole.log(p.getFakeAge())\n```\n\n- public 속성이라면 this 컨텍스트에는 age 속성이 하나기 때문에 age의 값이 20이다.\n\n```tsx\nclass Human {\n  #age = 10\n\n  getAge() {\n    return this.#age\n  }\n}\n\nclass Person extends Human {\n  #age = 20\n\n  getFakeAge() {\n    return this.#age\n  }\n}\n\nconst p = new Person()\nconsole.log(p.getAge()) // 10\nconsole.log(p.getFakeAge()) // 20\n```\n\n- **기존처럼 인스턴스별로 독립적인 공간을 갖지만, 추가로 클래스 별로 독립적인 공간을 갖는 것이다.**\n- Human 클래스 스코프의 #age와 Person 클래스 스코프의 #age는 다르다.\n- 그러므로 Human 클래스에 속한 getAge()가 실행될때는 Human의 #age에 접근하고 Person의 getFakeAge()가 실행될 때는 Person의 #age에 접근한다.\n\n## JavaScript # vs TypeScript private\n\n- runtime vs compile\n- TypeScript private는 컴파일 이후에 런타임에 적용되지 않는 문법\n"},{"excerpt":"javascript의 객체 복사 방법은 얕은 복사와 깊은 복사로 나뉜다. 얕은 복사 (Shallow Copy) Object.assign Spread Operator 그러나 위의 두 방법은 얕은 복사 만을 지원하며, 객체 구조가 복잡해질 경우에는 깊은 복사를 해야만 한다. clone의 내부 객체인 profile의 속성을 변경하는 경우, 원본도 변경된다. c…","fields":{"slug":"/contents/posts/2022-09-10/"},"frontmatter":{"date":"September 10, 2022","title":"이제 deep copy할 때 structuredClone을 씁시다."},"rawMarkdownBody":"\n> javascript의 객체 복사 방법은 얕은 복사와 깊은 복사로 나뉜다.\n\n## 얕은 복사 (Shallow Copy)\n\n### Object.assign\n\n```typescript\nconst person = { name: \"aila\", age: 10 }\nconst clonePerson = Object.assign({}, person)\nclonePerson.name = \"aila copy\"\n\nconsole.log(person) // { name: 'aila', age: 10 }\nconsole.log(clonePerson)\n```\n\n### Spread Operator\n\n```typescript\nconst person = { name: \"aila\", age: 10 }\nconst clonePerson = { ...person }\nclonePerson.name = \"aila copy\"\n\nconsole.log(person) // { name: 'aila', age: 10 }\nconsole.log(clonePerson)\n```\n\n그러나 위의 두 방법은 얕은 복사 만을 지원하며, 객체 구조가 복잡해질 경우에는 깊은 복사를 해야만 한다.\n\n```typescript\nconst person = { profile: { name: \"aila\", age: 10 }, like: \"computer\" }\nconst clonePerson = { ...person }\n\nclonePerson.profile.name = \"sunny\"\nclonePerson.like = \"book\"\n\nconsole.log(person) // { profile: { name: \"sunny\", age: 10 }, like: \"computer\" }\nconsole.log(clonePerson) // { profile: { name: \"sunny\", age: 10 }, like: \"book\" }\n```\n\nclone의 내부 객체인 profile의 속성을 변경하는 경우, 원본도 변경된다.  \nclone의 내부 객체인 profile은 original의 profile과 동일한 주소를 참조하고 있기 때문이다.\n\n## 깊은 복사\n\n### JSON.stringify(), JSON.parse()\n\n객체 -> 스트링 -> 객체의 변환 과정을 거쳐 깊은 복사를 할 수 있다.\n\n```typescript\nconst person = { profile: { name: \"aila\", age: 10 }, like: \"computer\" }\nconst clonePerson = JSON.parse(JSON.stringify(person))\n\nclonePerson.profile.name = \"sunny\"\nclonePerson.like = \"book\"\n\nconsole.log(person) // { profile: { name: 'aila', age: 10 }, like: \"computer\" }\nconsole.log(clonePerson) // { profile: { name: \"sunny\", age: 10 }, like: \"book\" }\n```\n\n### lodash cloneDeep\n\n```typescript\nconst person = { profile: { name: \"aila\", age: 10 }, like: \"computer\" }\nconst clonePerson = _.cloneDeep(person)\n\nclonePerson.profile.name = \"sunny\"\nclonePerson.like = \"book\"\n\nconsole.log(person) // { profile: { name: \"sunny\", age: 10 }, like: \"computer\" }\nconsole.log(clonePerson) // { profile: { name: \"sunny\", age: 10 }, like: \"book\" }\n```\n\n### structuredClone()\n\n```typescript\nconst person = {\n  profile: { name: \"aila\", age: 10 },\n  like: \"computer\",\n  date: new Date(),\n}\nconst clonePerson = structuredClone(person)\n\nclonePerson.profile.name = \"sunny\"\nclonePerson.like = \"book\"\n\nconsole.log(person) // { profile: { name: \"sunny\", age: 10 }, like: \"computer\", date: 2022-09-10T08:22:28.924Z }\nconsole.log(clonePerson) // { profile: { name: \"sunny\", age: 10 }, like: \"book\", date: 2022-09-10T08:22:28.924Z }\n```\n\n다음과 같이 json메서드에서 지원하지 않는 date타입도 복사가 되고 이제 더이상 외부 라이브러리를 사용하지 않아도 된다.  \n그러나, structuredClone도 완벽한 것은 아니다.\n\n![](https://velog.velcdn.com/images/nsunny0908/post/9a129521-b63f-41e6-bc9c-c7cf163dbd8f/image.png)\n\nhttps://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#things_that_dont_work_with_structured_clone\n\n위의 문서에 따르면 일부 기능에 있어서 제한이 있다.\n\n> 1. Function 객체\n> 2. DOM node\n> 3. RegExp객체들의 lastIndex, Property descriptors, setters, getters, 프로토타입 체인 등\n\n복잡한 구조의 객체 복사를 할 때 structuredClone()을 사용해보는 것도 좋겠다.\n"},{"excerpt":"문제상황 검색 시에 1페이지에서 검색하면 검색결과가 제대로 보이는데, 2페이지에 넘어가서 검색하면 검색결과가 보이지 않았다. 원인 서치인풋과 데이터테이블은 다른 컴포넌트로 되어있다. 현재 몇 페이지인지는  라는 데이터테이블 내부의 state로 관리되고 있다. 서버에서 페이지네이션 하지 않고 tableData를 currentPage라는 state값을 이용해…","fields":{"slug":"/contents/posts/2022-08-17/"},"frontmatter":{"date":"August 17, 2022","title":"페이지네이션 검색 관련 트러블슈팅"},"rawMarkdownBody":"\n# 문제상황\n\n- 검색 시에 1페이지에서 검색하면 검색결과가 제대로 보이는데, 2페이지에 넘어가서 검색하면 검색결과가 보이지 않았다.\n\n# 원인\n\n- 서치인풋과 데이터테이블은 다른 컴포넌트로 되어있다.\n- 현재 몇 페이지인지는 `currentPage` 라는 데이터테이블 내부의 state로 관리되고 있다.\n- 서버에서 페이지네이션 하지 않고 tableData를 currentPage라는 state값을 이용해 slice해주는 방식으로 클라이언트 사이드에서 페이지네이션 하고 있었다.\n- 페이지를 2페이지로 이동 후 검색 했을 때 **currenPage가 1로 초기화되지 않아 해당 이슈 발생**\n  → 데이터테이블 내부에서 검색했는지 안했는지를 알 수 없으므로 검색해도 계속 currentPage가 페이지네이션 된 2페이지로 남아있게 된 것.\n\n# 해결\n\n1. useEffect로 tableData를 잡고 변경될때마다 setState 해준다.\n2. currenPage를 전역으로 관리하고 검색하는 곳에서 검색할때마다 currenPage를 1로 초기화해준다.\n   → currentPage가 과연 전역으로 관리되어야할 값인가? 🤔\n3. 클라이언트단 말고 서버에서 페이지네이션을 한다.\n"},{"excerpt":"프론트앤드 스터디에서 진행한 OSI 7계층 중 2계층에 대한 발표자료 2계층 (데이터링크 계층, DataLink Layer) 네트워크 장비간의 신호를 주고받는 규칙을 정하는 계층 데이터를 전송할 때 발생하는 충돌을 막기 위해서 데이터를 송수신하는 순서나 규칙이 필요하게 되었다. 신호가 닿는 범위(세그먼트)에서의 데이터 전송에 관해서는 2계층에서 처리한다.…","fields":{"slug":"/contents/posts/2022-07-20/"},"frontmatter":{"date":"July 20, 2022","title":"OSI 7계층 중 2계층에 대해서 알아보자"},"rawMarkdownBody":"\n> 프론트앤드 스터디에서 진행한 OSI 7계층 중 2계층에 대한 발표자료\n\n# 2계층 (데이터링크 계층, DataLink Layer)\n\n- 네트워크 장비간의 신호를 주고받는 **규칙**을 정하는 계층\n- 데이터를 전송할 때 발생하는 충돌을 막기 위해서 데이터를 송수신하는 순서나 규칙이 필요하게 되었다.\n- 신호가 닿는 범위(세그먼트)에서의 데이터 전송에 관해서는 2계층에서 처리한다.\n\n1계층 장비(허브, 리피터)로 여러 컴퓨터에 데이터를 전달하려면?\n\n![](https://velog.velcdn.com/images/nsunny0908/post/25609c44-ee2e-45b8-80de-89818e097bb8/image.png)\n허브 사용\n\n![](https://velog.velcdn.com/images/nsunny0908/post/f4cdb6b6-0a75-4998-850f-249403367097/image.png)\n\n- 허브는 한 컴퓨터에서 전송된 데이터를 모든 컴퓨터에게 다 전송한다.  \n  이를 `플러딩`이라고 한다.  \n  → MAC 주소를 알지 못하기 때문.  \n  → 비효율적, 데이터 충돌 위험성⬆️\n\n  - 맥주소: NIC(랜카드)에 부여된 고유 식별 값.\n\n2계층에서 사용하는 장비인 스위치 브릿지 등은 MAC주소를 알기 때문에 4번이 1번pc한테만 전송하는게 가능하다.\n\n이것처럼, 우리는 2계층의 프로토콜과 장비들로 이런 문제를 해결할 수 있다.\n\n## 2계층의 장비들로 여러대의 컴퓨터를 연결하려면?\n\n- 네 대의 컴퓨터가 스위치라는 장비를 통해 연결되어 있다.\n\n![](https://velog.velcdn.com/images/nsunny0908/post/02a59af8-b85a-4294-8126-b394b60949b0/image.png)\n\n- 나머지 세 대의 컴퓨터가 ‘예림'의 컴퓨터로 데이터를 동시에 보냈다고 가정했을때 ‘예림'이의 컴퓨터는 데이터를 0101111110001.. 형식으로 붙어서 받게 된다.\n\n![](https://velog.velcdn.com/images/nsunny0908/post/8a9b8d55-5c02-4087-9cc3-8e1dbba2d7f5/image.png)\n\n- 제대로 잘 끊어서 받지 않으면 엉뚱한 데이터를 받게 된다.\n- 제대로 잘 끊어서 데이터를 받기 위해 데이터를 보내는 쪽은 **데이터의 앞, 뒤에 특정한 비트열**을 붙인다.\n\n![](https://velog.velcdn.com/images/nsunny0908/post/74ed3636-a1ae-494f-9d22-5de1f02ce3e4/image.png)\n\n![](https://velog.velcdn.com/images/nsunny0908/post/c0ab96d9-f764-41a0-9099-6f2bd9d59a90/image.png)\n\n→ 이 과정을 `프레이밍`이라고 한다.\n\n## 이더넷\n\n- LAN의 2계층에서 사용되는 프로토콜 (규칙)\n- 고유의 주소를 이용해 데이터를 주고받을 수 있도록 한다.\n- 주소는 데이터 전송 방법에 따라 3가지 종류가 있다.\n\n### 유니캐스트\n\n- 1:1 통신\n- 가장 일반적이다.\n- 각각의 기기는 유니캐스트의 주소를 반드시 하나 갖고 있다.\n- 유니캐스트의 주소는 유일해야한다.\n\n### 브로드캐스트\n\n- 세그먼트 내의 모든 기기에게 메세지를 보내는 데이터 통신\n\n### 멀티캐스트\n\n- 1:N\n- 같은 주소를 가진 기기가 여러개 있을 수 있다.\n\n각각의 기기는 유니캐스트의 주소를 반드시 하나 갖고있다.  \n반면에 멀티캐스트는 같은 주소를 가진 기기가 여러개 있어도 되는데, 멀티캐스트 주소는 ‘그룹'과 같은 취급을 하기 때문이다.  \n멀티캐스트가 1대 다수에게 메세지를 보내는 주소라고 했으니까, 굳이 각각 기기의 유니캐스트에게 보낼 필요 없이, 여러개의 기기를 아우르는 주소의 그룹에게 보내면 되는 것!\n\n그러니까, 멀티캐스트의 그룹에 속한 기기는 자신의 유니캐스트 주소 1개와 멀티캐스트 주소 이렇게 총 2개의 주소를 갖게 된다.\n\n예를 들자면, A라는 회사 개발팀 소속 kim에게 편지를 보내는 상황이 있다고 가정해보자.  \n수신처를 kim이라고 하면 유니캐스트로 수신을 하게 되는거고, A회사의 개발팀 으로 수신처를 정하게 되면 멀티캐스트로 수신하게 되는 것이다.\n\n## MAC주소\n\n- 인터페이스에 지정된 고정 주소\n\n## 이더넷은 어떻게 데이터를 송신할까?\n\n### 신호\n\n- 허브로 연결되어 있는 컴퓨터는 같은 충돌 도메인에 있기 때문에 충돌이 발생한다.\n- 이더넷에서는 수신한 수신처의 MAC주소를 보고 해당 MAC주소가 아닌 다른 프레임은 다 파기하게 된다.\n- 그렇기 때문에 주소라는건 수신처가 자기인지 아닌지를 체크하기 위해서 있다고 할 수 있다.\n\n그렇다면 멀티캐스트랑 브로드캐스트는 그룹으로 묶인 주소를 가지고 있을텐데 이 경우에는 어떻게 판단하게 될까?\n\n멀티캐스트는 주소에 그룹의 번호가 들어있기 때문에 자신이 그 그룹의 소속되어있다면 수신하고 그 외의 경우는 파기하게 되고, 브로드캐스트는 어차피 전체 수신이때문에 반드시 수신하게 된다.\n\n### 충돌\n\n- 이더넷에서는 신호가 겹쳐서 충돌이 일어나지 않게 하는데 이를 위해서 CSMA/CD 라는 액세스 제어를 시행한다.\n\n### CSMA/CD\n\n- Carrier Sense(CS) : 송신자가 현재 회선에 신호가 흐르는지 탐지해서 누군가 송신중이라면 송신하지 않는다.\n- Multiple Access(MA) : 아무도 송신하고 있지 않아 안전할 경우 송신을 허용한다.\n- Collision Detection(CD) : 그다음 충돌을 탐지해 충돌이 일어나면 다시 재수행한다.\n\n→ 하지만 타이밍을 겹치지 않게 엇갈리게 해줄 뿐, 충돌을 모두 막아줄 수 없다.\n\n## 스위치\n\n- 허브에 여러가지 기능을 추가\n- 신호가 지나는 길을 나누는 방법을 사용해 충돌을 막아주는 기기\n  (허브는 충돌이 발생하지 않도록 하기 위해서 신호를 보내는 타이밍을 겹치지 않게 엇갈리게 한다. 그런데 이 방법은 충돌을 모두 막아줄수가 없다. 우연치않게 타이밍이 겹치게 되면 충돌이 일어나기 때문이다.)\n\n### MAC 주소 테이블\n\n- 포트에 연결되어있는 컴퓨터의 MAC주소를 기억하고 데이터베이스로 갖고 있다.\n\n### 스위치가 MAC 주소 테이블을 작성하는 과정\n\n- 통신을 하기 전까지는 MAC 주소 테이블은 비어 있다.\n\n![](https://velog.velcdn.com/images/nsunny0908/post/72150b11-a9e2-4a2d-9462-b6555ab62e9d/image.png)\n\n- 컴퓨터 1이 컴퓨터 3으로 데이터를 전송했을 때 데이터는 스위치를 거치면서 MAC 주소 테이블에 컴퓨터1의 맥주소가 추가된다.\n\n![](https://velog.velcdn.com/images/nsunny0908/post/954a35bd-47f1-4562-b7de-cdfe33bed9e1/image.png)\n\n- 컴퓨터 3으로 데이터를 보내야하는데 목적지의 MAC 주소를 모르기 때문에 플러딩이 발생한다.\n\n![](https://velog.velcdn.com/images/nsunny0908/post/dd0cf92b-7510-4608-a59c-7c5c60a8a0e2/image.png)\n\n- 목적지의 MAC주소를 아는 경우, 목적지에만 데이터를 전송하고 나머지 컴퓨터에는 데이터를 전송하지 않는다.\n- 수신처가 다른 프레임이 동시에 스위치에 도착하게 되어도 충돌은 발생하지 않게 된다.\n\n![](https://velog.velcdn.com/images/nsunny0908/post/63772d61-d984-4e91-bde8-ed05de40331b/image.png)\n\n그런데 만약에 수신처가 같은 프레임이 동시에 도달한 경우에는 어떻게 될까?  \n여기서 버퍼링이라는 개념이 나오게 된다.\n\n## 버퍼\n\n- 일시적으로 데이터를 기록해 둘 수 있는 메모리\n- 충돌할 것 같은 프레임을 버퍼에 일시적으로 저장\n- 먼저 보냈던 프레임의 송신이 끝나면 저장해뒀던 프레임을 송신한다. (임시피난소 느낌)\n- 용량이 제한되어 있다.\n- 특정한 규격을 사용해 버퍼가 부족할 것 같다고 판단되면 백 프레셔 등과 같은 규격을 사용해 송신을 중지한다.\n\n## 버퍼링\n\n- 버퍼(Buffer)를 사용한 처리를 실행하는 것\n- 먼저 보냈던 프레임의 송신이 끝나면 저장해뒀던 프레임을 송신하는 것\n\n## 전이중 통신\n\n- 송신과 수신을 동시에 할 수 있는 방식\n- ↔ CSMA/CD : 반이중 통신\n\n## 전이중 이더넷\n\n- 스위치는 전이중 통신이기 때문에 충돌을 염려할 필요가 없다. -> CSMA/CD를 사용할 필요가 없다.\n- 스위치를 사용해 전이중 통신을 하는 것\n\n## 📝 정리\n\n1. 데이터링크 레이어는 ‘데이터를 어떻게 송수신할건지'를 생각하고 ‘규칙을 정하는’ 역할을 하는 계층이다.\n2. 2계층의 이더넷은 고유의 주소를 이용해 데이터를 주고받을 수 있도록 한다.\n3. 스위치는 허브와 달리 MAC 주소 테이블을 이용해 수신처에 해당하는 데이터만 전송할 수 있다.\n"},{"excerpt":"요구사항 모달이 2개 이상 띄워져있을 때 가장 위의 것부터 close되게 해주세요. 기존 모달의 구조 body에 적용된 handleKeydown 이벤트 안에서 가 escape key일경우에 onClose를 해주었다. 때문에, 모달이 2개 이상 띄워져도 esc를 누르면 한꺼번에 close되고 있었다. 1차 리팩토링 ModalRoot에 ref를 지정해줘서, …","fields":{"slug":"/contents/posts/2022-06-25/"},"frontmatter":{"date":"June 25, 2022","title":"Modal esc 관련 트러블 슈팅"},"rawMarkdownBody":"\n# 요구사항\n\n- 모달이 2개 이상 띄워져있을 때 가장 위의 것부터 close되게 해주세요.\n\n# 기존 모달의 구조\n\n- body에 적용된 handleKeydown 이벤트 안에서 `e.key`가 escape key일경우에 onClose를 해주었다. 때문에, 모달이 2개 이상 띄워져도 esc를 누르면 한꺼번에 close되고 있었다.\n\n```ts\nexport const Modal = function Modal({\n  open,\n  onClose,\n  isInterrupt,\n  children,\n}: ModalProps) {\n\n    ...\n\n  useEffect(() => {\n    if (!open) {\n      return\n    }\n\n    const ESCAPE_KEY = 'Escape'\n\n    const handleKeydown = (e: KeyboardEvent): void => {\n      if (onClose && e.key === ESCAPE_KEY) {\n        onClose()\n      }\n    }\n\n    ...\n\n  }, [open])\n\n    ...\n\n  return (\n    <Modal open={open}>\n      <ModalRoot role=\"presentation\">\n        <ModalDim\n          .....\n        />\n        {children}\n      </ModalRoot>\n    </Modal>\n  )\n}\n```\n\n# 1차 리팩토링\n\n- ModalRoot에 ref를 지정해줘서, ref.current와 modals의 마지막 요소가 같지 않으면 return해주었다.\n\n```ts\nconst modalRef = useRef<HTMLDivElement>(null)\n\nuseEffect(() => {\n  if (!open) {\n    return\n  }\n  const ESCAPE_KEY = 'Escape'\n\n  const handleKeydown = (e: KeyboardEvent): void => {\n    if (onClose && e.key === ESCAPE_KEY) {\n      const modals = document.querySelectorAll(`[role=${MODAL_ROLE}]`)\n\n      if (modals[modals.length-1] !== modalRef.current) {\n        return\n      }\n\n      onClose()\n    }\n  }\n\n  ...\n\n}, [open])\n\n...\n\n\nreturn (\n  <Modal open={open}>\n    <ModalRoot role={MODAL_ROLE} ref={modalRef}>\n      <ModalDim\n          ...\n      />\n      {children}\n    </ModalRoot>\n  </Modal>\n)\n```\n\n# 2차 리팩토링\n\n- escape key를 지정해주는건 너무 메뉴얼하다. 만약에 앱도 제공한다고 가정한다면 esc는 작동되지 않을 것이다.\n\n### HTMLDialogElement.showModal()\n\nhttps://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement/showModal\n\n> showModal()메서드는 다른 대화 상자 위에 대화 상자를 모달로 표시합니다. `::backdrop` 요소 와 함께 최상위 레이어에 표시됩니다.\n> 대화 상자 외부의 상호 작용이 차단되고 대화 상자 외부의 콘텐츠가 비활성화됩니다.\n\n- 아직 실험적 기술이라는 HTMLDialogElement의 `showModal()`. 해당 메서드를 사용하게 되면 esc key를 매뉴얼하게 지정하지 않아도 이미 esc를 통해 close하는 기능이 적용되어있다.\n\n- modal을 `dialog`태그로 변경하고 showModal 메서드를 사용하도록 리팩토링했다.\n\n```ts\nconst modalRef = useRef<HTMLDialogElement>(null)\n\nuseEffect(() => {\n  if (open) {\n    modalRef.current?.showModal()\n  }\n}, [open])\n\n....\n\nreturn (\n  <Modal open={open}>\n    <ModalRoot\n      role={MODAL_ROLE}\n      ref={modalRef}\n      onClose={(e) => {\n        e.preventDefault()\n        const modals = document.querySelectorAll(`[role=${MODAL_ROLE}]`)\n        if (modals[modals.length-1] !== modalRef.current) {\n          return\n        }\n        onClose?.()\n      }}\n    >\n      <ModalDim\n        ...\n      />\n      {children}\n    </ModalRoot>\n  </Modal>\n)\n```\n\n# 문제상황\n\n- 위와 같이 2차 리팩토링까지 마쳤을때 modal은 기능상으로 전혀 문제가 없었다. 하지만, jest에서 테스트가 깨졌다.  \n  jest에서 showModal() 메서드를 아예 찾지 못하는 문제가 발생했다.\n\n![](https://velog.velcdn.com/images/nsunny0908/post/36d9abd1-7383-4b9d-a9d9-f73fbd07b8f7/image.png)\n\n해당 문제를 해결하려고 구글링을 하다가, 나와 비슷한 문제를 겪은 사람을 발견했다.\n\n[TypeError: scrollIntoView is not a function](https://stackoverflow.com/questions/53271193/typeerror-scrollintoview-is-not-a-function/53294906#53294906)\n\njest내에서 임의로 함수를 모킹해서 해결했다는 내용이였다.\n\n![](https://velog.velcdn.com/images/nsunny0908/post/0c570420-98bc-454a-ada6-40189009afe1/image.png)\n\n그래서 모킹해줬더니,\n\n```ts\nwindow.HTMLDialogElement.prototype.showModal = jest.fn()\n```\n\n![](https://velog.velcdn.com/images/nsunny0908/post/03504b84-7bb5-4c2b-85ba-ade58f754009/image.png)\n\n타입에러가 떴다.\n\n# 삽질 결과 🪓\n\n- jest는 jsdom에서 돌아간다. (jsdom이 브라우저 환경인 것처럼 시뮬레이션해주는 역할)  \n  jsdom 에서 htmldialogElement가 서포트가 안되는 게 문제의 원인이였다.. 😇 (함수를 찾을 수 없다고 뜬 이유)\n\n  https://stackoverflow.com/questions/53271193/typeerror-scrollintoview-is-not-a-function/53294906#53294906\n\n  게다가 typescript에서도 아직까지 dialog 태그에 대한 충분한 지원이 되지 않는 것 같다. (타입 에러가 뜬 이유)\n\n  https://github.com/Microsoft/TypeScript/issues/16880\n\n# 느낀 점\n\n- 실험적 기술은 생각보다 지원이 되지 않는 라이브러리들이 많다는 걸 느꼈다..😹\n\n  ![](https://velog.velcdn.com/images/nsunny0908/post/bfa3bcd0-0779-4679-8e3b-70e083efbc4c/image.png)\n"},{"excerpt":"다음과 같은 object가 있다고 하자. age라는 key를 삭제하고 싶으면 어떻게 해야할까? delete 객체의 속성을 제거 delete를 사용하면 안되는 이유 object의 불변성(Immutability)을 해치게 된다.  존재하지 않는 속성을 삭제하려고 하면 delete는 어떠한 작업도 없이 true를 반환한다. 불변성을 지키면서 object key…","fields":{"slug":"/contents/posts/2022-06-11/"},"frontmatter":{"date":"June 11, 2022","title":"Object Delete"},"rawMarkdownBody":"\n```ts\nconst person = {\n  firstName: \"Namsun\",\n  lastName: \"Kim\",\n  age: 1,\n}\n```\n\n다음과 같은 object가 있다고 하자.  \nage라는 key를 삭제하고 싶으면 어떻게 해야할까?\n\n# delete\n\n- 객체의 속성을 제거\n\n```ts\ndelete person.age\n```\n\n# delete를 사용하면 안되는 이유\n\n- object의 불변성(Immutability)을 해치게 된다.\n\n```ts\nconst person = {\n  firstName: \"Namsun\",\n  lastName: \"Kim\",\n  age: 1,\n}\n\nconsole.log(\"person 삭제 전 : \", person)\n\ndelete person.age\nconsole.log(\"person 삭제 후 : \", person)\n```\n\n![](https://velog.velcdn.com/images/nsunny0908/post/4606065a-8865-4979-a380-69c6a1f5c5e1/image.png)\n\n- 존재하지 않는 속성을 삭제하려고 하면 delete는 어떠한 작업도 없이 true를 반환한다.\n\n```ts\nconst person = {\n  firstName: \"Namsun\",\n  lastName: \"Kim\",\n  age: 1,\n}\n\ndelete person.age //true반환\n```\n\n# 불변성을 지키면서 object key를 삭제하는 방법\n\n## spread operator\n\n```ts\nconst person = {\n  firstName: \"Namsun\",\n  lastName: \"Kim\",\n  age: 1,\n}\n\nconsole.log(\"person 삭제 전 : \", person)\n\nconst { age, ...otherKey } = person\n\nconsole.log(\"person 삭제 후 : \", person)\nconsole.log(\"person 삭제 후 otherKey: \", otherKey)\n```\n\n![](https://velog.velcdn.com/images/nsunny0908/post/2a8f5c26-ba4e-4e3e-993a-91eb58c302ea/image.png)\n\n## Object.fromEntries + Object.entries\n\n```ts\nObject.fromEntries(\n  Object.entries(person).filter(([key]) => !key.includes(\"age\"))\n)\n```\n\n![](https://velog.velcdn.com/images/nsunny0908/post/1f6c690e-f64f-4309-bf0f-550933de99dc/image.png)\n\n## Object.entries\n\n- `[key, value]` 쌍의 배열을 반환\n\n```ts\nObject.entries(person)\n```\n\n```\n[\n  [\"firstName\", \"Kim\"],\n  [\"lastName\", \"Namsun\"],\n  [\"age\", 1],\n]\n```\n\n## Object.fromEntries\n\n- 키값 쌍의 목록을 객체로 바꾼다.\n\n```ts\nObject.fromEntries([\n  [\"firstName\", \"Kim\"],\n  [\"lastName\", \"Namsun\"],\n  [\"age\", 1],\n])\n```\n\n```ts\n{ firstName: 'Kim', lastName: 'Namsun', age: 1 }\n```\n\n```ts\nObject.fromEntries(\n  Object.entries(person).filter(([key]) => !key.includes(\"age\"))\n)\n```\n"},{"excerpt":"Debounce 빠르게 호출되는 중간 과정을 보여주지 않고 결과를 모아 보여줘도 문제가 되지 않을 경우 많이 사용\n(resize, keydown) Lodash Documentation 요구사항 키를 입력할때마다 검색 api를 호출하는 기능에 debounce를 적용하기 처음 작성했던 코드 lodash debounce를 사용해 처음 작성한 코드. 문제사항 그…","fields":{"slug":"/contents/posts/2022-06-05/"},"frontmatter":{"date":"June 05, 2022","title":"debounce 트러블 슈팅"},"rawMarkdownBody":"\n# Debounce\n\n- 빠르게 호출되는 중간 과정을 보여주지 않고 결과를 모아 보여줘도 문제가 되지 않을 경우 많이 사용\n  (resize, keydown)\n\n[Lodash Documentation](https://lodash.com/docs/4.17.15#debounce)\n\n# 요구사항\n\n- 키를 입력할때마다 검색 api를 호출하는 기능에 debounce를 적용하기\n\n# 처음 작성했던 코드\n\nlodash debounce를 사용해 처음 작성한 코드.\n\n```ts\nconst handleSearch = debounce(() => {\n  if (!onSearch) {\n    return\n  }\n\n  ...\n}, 500)\n```\n\n# 문제사항\n\n그런데 debounce가 제대로 작동되지 않았다.\n0.5초 후에 하나만 호출되는 것이 아니라 0.5초 이후에 한꺼번에 호출되었다.\n입력할때마다 리액트 컴포넌트가 리렌더링되기 때문에 debounce도 계속 새 debounce를 호출한다.\n\n# 해결\n\nuseCallback으로 처음에만 debounce를 불러와 재사용하도록 했다.\n\n```ts\nconst handleSearch = useCallback(\n  debounce(() => {\n    if (!onSearch) {\n      return\n    }\n\n    ...\n  }, 500),\n  [inputValue]\n)\n```\n\n# 또다른 문제사항\n\n- search input에 `abc`를 입력할 경우 검색 api 3개가 호출되었다.\n  (a, ab, abc)\n\n- 기대상황: abc를 연속적으로 입력할 경우 abc의 경우만 호출되어야한다.\n\n# 해결\n\n의존성 배열 삭제함으로써 a든 ab든 abc든 같은 debounce를 바라보게 해주었다.\n\n```ts\nconst handleSearch = useCallback(\n  debounce(() => {\n    if (!onSearch) {\n      return\n    }\n\n    ...\n  }, DEFAULT_DEBOUNCE_TIME),\n  []\n)\n```\n"},{"excerpt":"가장 먼저!\n프론트앤드 개발자가 개발하는 방식 생각해보기 디자이너가 전달해준 디자인을 보고 마크업을 시작한다. 브라우저에서 렌더링된 결과를 확인하는 과정을 거친다. 필요한 기능의 요구사항을 확인한 후 기능을 추가한다. 제대로 동작하는지 브라우저에서 확인한다. 기존의 코드를 리팩토링한다. 리팩토링 전과 동일하게 동작하는지 확인한다. -> 사실 우리는 테스트…","fields":{"slug":"/contents/posts/2022-05-22/"},"frontmatter":{"date":"May 22, 2022","title":"프론트앤드에서의 테스트 (나에겐 너무나 멀고 힘든 테스트코드 짜기..)"},"rawMarkdownBody":"\n가장 먼저!\n프론트앤드 개발자가 개발하는 방식 생각해보기\n\n> 1. 디자이너가 전달해준 디자인을 보고 마크업을 시작한다.\n> 2. 브라우저에서 렌더링된 결과를 확인하는 과정을 거친다.\n\n> 1. 필요한 기능의 요구사항을 확인한 후 기능을 추가한다.\n> 2. 제대로 동작하는지 브라우저에서 확인한다.\n\n> 1. 기존의 코드를 리팩토링한다.\n> 2. 리팩토링 전과 동일하게 동작하는지 확인한다.\n\n-> 사실 우리는 테스트와 개발을 동시에 하고, 어쩌면 테스트를 하는데 더 많은 시간을 사용한다.\n\n# 테스트란?\n\n\" 프로그램을 실행하여 오류와 결함을 검출하고 애플리케이션이 요구사항에 맞게 동작하는지 검증하는 절차 \"\n\n# 우리는 테스트를 왜 해야하는가\n\n> 1. 발생 가능한 결함을 예방하고 요구사항을 충족시키는지 확인\n> 2. 개발 과정에서 생기는 변경 사항들로 인해 새로운 결함이 유입되지 않았는지 확인\n\n테스트를 통해서 불필요한 버그가 없는 코드를 작성할 수 있고,\n좋은 코드를 자신있게 작성할 수 있게 된다.\n\n그러나 가장 큰 문제가 있다.\n\n## \"테스트에는 너무 많은 시간과 노력이 필요하다.\"\n\n![](https://velog.velcdn.com/images/nsunny0908/post/0d8089ef-a866-46c9-b489-13c5e564fdbd/image.png)\n\n## Write test\n\n새벽 2시에 전화받고 버그를 수정하는 것보다 테스트에서 버그를 잡는 것이 훨씬 낫다.\n\n테스트를 작성하는게 구현하는것보다 시간이 더 걸릴 수도 있지만 확실하게 유지보수하는 시간을 절약할 수 있다.\n\n테스트를 작성할 때 생각해야 하는 것은 **테스트로 인해 이 프로젝트에 버그가 없다는 확신을 얼마나 가져오는가**에 대한 것이다.\n\nTypeScript와 ESLint와 같은 언어와 도구를 사용하면 좋지만, 이것들은 비즈니스 로직에 버그가 없다고 보장해주지 않기 때문에 테스트를 작성해야 한다.\n\n## Not too many\n\n테스트 커버리지가 70%이상일 경우, 오히려 테스트에서 감소하는 수익을 얻는다.\n\n테스트 환경에서 재현하기 어려운 한 줄의 코드를 테스트 통과 시키기 위해 구현되는 세부적인 것들을 테스트하고 있을 수도 있다.\n\n## Mostly integration\n\n테스팅 트로피: 소프트웨어 테스트를 위한 4계층의 검증된 방법\n![](https://velog.velcdn.com/images/nsunny0908/post/28e3a427-096d-4cdf-9f11-4d81e56f079d/image.png)\n\n## 테스팅 트로피로 알아보는 테스트의 유형\n\n- Static Test (정적 테스트) - 코드를 실행시키지 않고 하는 테스트\n  오타, 참조에러, 타입에러 등 개발자의 실수로 발생할 수 있는 에러를 잡아준다.\n  ESLint, Typescript\n- Unit Test (단위 테스트)\n  작은 단위를 떼어내서 테스트\n  함수/클래스같은 개별 유닛에 값을 넣고 예상한 값이 나오게 하도록 테스트한다.\n- Integration Test (통합 테스트)\n  여러 부분들이 통합되어 어떤 side effect가 있는지 등을 포함해 원하는 결과가 나오도록 테스트한다.\n- E2E Test\n  사용자 시나리오대로 테스트했을 때 해당 제품이 잘 돌아가는지 테스트한다.\n\n마틴 파울러가 설명한 테스트의 단계\n![](https://velog.velcdn.com/images/nsunny0908/post/5930470f-9a95-4a77-98f1-c4538389c8c2/image.png)\n\nE2E 테스트는 가장 느리며, 비용이 많이 드는 반면 Unit 테스트는 가장 저렴하며 빠르다.\n\n그러나 Unit Test만 하면 UI테스트의 이점을 가져갈 수 없다.\n\nUI테스트와 Unit테스트의 중간 특성을 지닌 통합테스트를 위주로 작성하자.\n왜 통합테스트가 중요할까?\n[https://twitter.com/erinfranmc/status/1148986961207730176](https://twitter.com/erinfranmc/status/1148986961207730176)\n→ 유닛이 개별적으로 작동하는지 확인하는 유닛 테스트가 중요하지 않다는 것은 아니지만 제대로 함께 작동하는지 확인하지 않으면 아무 소용이 없다.\n\n**통합 테스트는 자신감과 속도/비용 간의 균형을 훌륭하게 유지하는 테스트이다.**\n\n# 프론트앤드 관점에서의 테스트\n\n프론트앤드 개발자가 뭘 하는 개발자인지 생각해보면 그 답은 명확해진다.\n\n1. 시각적 요소\n   입력값 (사용자의 액션), 출력값 (사용자의 액션에 따른 화면의 변화)를 검증\n\n   - 스냅샷 테스트\n     HTML구조가 의도한 대로 나타나는지를 테스트\n\n   - 시각적 회귀 테스트\n     HTML에 CSS를 더해서 컴포넌트가 실제로 브라우저에서 렌더링되는 모습이 의도한 대로 나타나는지를 테스트\n     storybook, chromatic\n\n2. 사용자 이벤트 처리\n\n```ts\nimport userEvent from \"@testing-library/user-event\"\n\nuserEvent.type(input, \"인풋에 입력\")\nuserEvent.click(button)\n```\n\n3. API 통신\n   보통 mocking하여 사용\n\n- mocking : 해당 코드가 의존하는 부분을 가짜(mock)로 대체하는 기법\n\n```ts\ntest(\"returns undefined by default\", () => {\n  // 함수 인스턴스를 만듦.\n  const mock = jest.fn()\n\n  // mock 함수에 foo라는 인자를 전달해줌.\n  const result = mock(\"foo\")\n\n  expect(result).toBeUndefined()\n  expect(mock).toHaveBeenCalled()\n  expect(mock).toHaveBeenCalledTimes(1)\n  expect(mock).toHaveBeenCalledWith(\"foo\")\n})\n```\n\n```ts\nconst doAdd = (a, b, callback) => {\n  callback(a + b)\n}\n\ntest(\"calls callback with arguments added\", () => {\n  const mockCallback = jest.fn()\n  doAdd(1, 2, mockCallback)\n  expect(mockCallback).toHaveBeenCalledWith(3)\n})\n```\n\n# 테스트 개발론\n\n## TDD (Test-Driven-Development)\n\n![](https://velog.velcdn.com/images/nsunny0908/post/6f82d765-c955-48c2-ae0b-71d009004dd8/image.png)\n\n- 테스트를 먼저 작성하는 테스트 주도 개발\n- 궁극적 목표 : Clean Code that works (작동하는 깔끔한 코드)\n- 어떻게 Testable Code를 작성할 수 있을까?\n  → **관심사의 분리**\n\n[[A5] 프론트엔드에서 TDD가 가능하다는 것을 보여드립니다.](https://youtu.be/L1dtkLeIz-M)\n\n## BDD (Behavior-Driven-Development)\n\n- TDD에서 확장\n- 애플리케이션의 동작에 초점을 맞추는 행위 주도 개발\n- 시나리오를 기반으로 테스트 케이스를 작성\n\n### given-when-then\n\n- 테스트 시나리오 작성을 세 섹션(given, when, then)으로 나누는 것\n\ngiven: 동작 작동 전에 필요한 것들을 설명\nwhen: 동작\nthen: 동작으로 인해 예상되는 변경 사항에 대한 설명\n\n```ts\ndescribe(\"<SearchInput />\", () => {\n  it(\"검색 인풋이 렌더링 된다.\", () => {\n    // given\n    const placeholderText = \"test searchInput\"\n\n    // when\n    render(<SearchInput placeholder={placeholderText} />)\n\n    const $input = screen.getByDisplayValue(\"\")\n    const $icon = screen.getByText(\"search\")\n\n    // then\n    expect($input).toBeInTheDocument()\n    expect(screen.getByPlaceholderText(placeholderText)).toBeInTheDocument()\n    expect($icon).toBeInTheDocument()\n  })\n  it(\"검색 인풋에 오토포커싱 한다.\", () => {\n    // given\n    const autoFocus = true\n\n    // when\n    render(<SearchInput autoFocus={autoFocus} />)\n\n    const $input = screen.getByDisplayValue(\"\")\n\n    // then\n    expect($input).toHaveFocus()\n  })\n\n  it(\"유저 입력 후 엔터를 눌렀을 때 검색기능이 동작한다.\", () => {\n    // given\n    const handleSearch = jest.fn()\n    const inputValue = \"test\"\n\n    // when\n    render(<SearchInput onSearch={handleSearch} />)\n\n    const $input = screen.getByDisplayValue(\"\")\n\n    userEvent.type($input, `${inputValue}{enter}`)\n\n    // then\n    expect(handleSearch).toBeCalledWith(expect.any(Object), inputValue)\n  })\n})\n```\n"},{"excerpt":"프론트앤드 스터디에서 진행한 OSI 7계층 중 1계층에 대한 발표자료 1계층 (물리계층, Physical Layer) 송신측에서 마지막으로 수행, 수신측에서 가장 먼저 수행되는 계층  1계층의 역할 을 알아보기 전에, 네트워크 통신을 한다는건 뭘까? 0과 1을 잘 주고받을 수 있다. 왜 0과 1일까? → 모든 파일과 프로그램은 0과 1의 나열이기 때문에.…","fields":{"slug":"/contents/posts/2022-04-01/"},"frontmatter":{"date":"April 01, 2022","title":"OSI 7계층 중 1계층에 대해서 알아보자"},"rawMarkdownBody":"\n> 프론트앤드 스터디에서 진행한 OSI 7계층 중 1계층에 대한 발표자료\n\n# 1계층 (물리계층, Physical Layer)\n\n- 송신측에서 마지막으로 수행, 수신측에서 가장 먼저 수행되는 계층\n\n![](https://media.vlpt.us/images/nsunny0908/post/fc9fdd09-d01c-46b6-b666-0fdd3dfe39fb/image.png)\n\n## 1계층의 역할\n\n을 알아보기 전에,\n\n**네트워크 통신을 한다는건 뭘까**?\n\n- 0과 1을 잘 주고받을 수 있다.\n- 왜 0과 1일까? → 모든 파일과 프로그램은 0과 1의 나열이기 때문에.\n- 0과 1은 비트이다.\n- 비트는 신호로 주고 받을 수 있다.\n\n**물리계층의 역할**\n\n- 물리계층은 통신매체를 통해 0, 1이 잘 전달될 수 있도록 하는 역할을 한다.\n- 데이터 전달 → 1계층 역할\n- 전달 전과 전달 후 의 일 → 2계층 이상의 역할\n\n![](https://media.vlpt.us/images/nsunny0908/post/446bd566-486e-42bf-bdc9-aac0d456bfd3/image.png)\n\n**1번 컴퓨터에서 2번 컴퓨터로 데이터를 전송하려면?**\n\n- 기기와 기기를 케이블로 연결\n\n![](https://media.vlpt.us/images/nsunny0908/post/8d533456-6c46-4de0-b1f9-815084744c4f/image.png)\n\n케이블\n\n- 통신 매체 (기기와 기기 사이를 연결해서 신호가 지나갈 수 있게 연결다리, 파이프 역할)\n\n### 📝 정리\n\n- **물리계층은 통신매체를 통해 신호를 전달하는 역할을 한다.**\n\n---\n\n## 신호\n\n- 신호에는 아날로그 신호, 디지털 신호가 있다.\n\n### 아날로그 신호 (0과 1 사이 어딘가의 값, 딱 떨어지지 않는다.)\n\n- 주파수에 따라 전송되는 신호\n\n![](https://media.vlpt.us/images/nsunny0908/post/310b1015-7114-41c8-a03a-451948add571/image.png)\n\n### 디지털 신호 (0이거나 1이거나, 0일땐 off, 1일땐 on)\n\n![](https://media.vlpt.us/images/nsunny0908/post/269e88b4-3eca-4ae9-b96d-db7887b4be64/image.png)\n\n### 주파수\n\n- 단위는 헤르츠\n\n![](https://media.vlpt.us/images/nsunny0908/post/0ed5c5f8-8603-467e-9e4b-ffc83bffb31e/image.png)\n→ 파동이 진행되는 내내 주파수가 4인 파동 (1초동안 4번의 파ㅇ도)\n\n![](https://media.vlpt.us/images/nsunny0908/post/4f6fbc0f-0d4f-4471-ad50-9b0cff8133d3/image.png)\n→ 파동이 진행되는 동안 주파수 값이 계속 변하는 파동\n\n![](https://media.vlpt.us/images/nsunny0908/post/8d533456-6c46-4de0-b1f9-815084744c4f/image.png)\n→ 1~5hz만 통과시킬 수 있는 케이블\n\n- 이 케이블을 통해 이 주파수가 흘러들어간다고 하면, 1~5hz만 통과시키기 때문에 보낸 데이터와 받은 데이터가 달라지게 된다.\n\n그러면 어떻게 해야할까?\n\n![](https://media.vlpt.us/images/nsunny0908/post/269e88b4-3eca-4ae9-b96d-db7887b4be64/image.png)\n\n→ 이런 주파수만 주고받을 수 있다면 데이터를 정상적으로 주고받을 수 있다.\n\n→ 0 ~ 무한대 hz의 주파수 범위를 가진다.\n\n→ 따라서 이 신호를 통과시킬 수 있는 통신매체는 없다.\n\n**그렇다면 아날로그 신호로 바꿔서 전송해야한다.**\n\n1. 송신 측에서는 원본 데이터를 아날로그 신호로 바꿔서 케이블을 통해 내보낸다. (인코딩)\n2. 수신측에서는 그 아날로그 신호를 받아서 다시 원본데이터로 해석한다. (디코딩)\n\n![](https://media.vlpt.us/images/nsunny0908/post/c805a30d-342b-46a0-a3c4-f47d2262718f/image.png)\n\n- 송신측과 수신측이 있다.\n- 송신측에서 0101 0101이라는 원본데이터를 보내려고 한다.\n- 이 원본데이터를 인코더를 통해 아날로그 신호로 변환한다.\n- 변환한 아날로그 신호를 전선(케이블)을 통해 전달한다.\n- 전달한 아날로그 신호를 받아서 수신측에서 디코더를 통해 원본데이터로 변환한다.\n\n간단한 함수로 살펴보자.\n\n```tsx\nconst encoder = (data: OriginData): AnalogSignal  => {\n\t...\n\treturn analogSignal\n}\n\nconst decoder = (analogSignal: AnalogSignal): OriginData  => {\n\t...\n\treturn originData\n}\n```\n\n물리계층은 하드웨어적으로 PHY칩에 구현이 되어있다.\n\n![](https://media.vlpt.us/images/nsunny0908/post/bcaa030a-78fe-4bea-8a1a-458f71081b26/image.png)\n\n---\n\n## 신호에 발생하는 문제\n\n- 감쇠, 노이즈, 충돌\n\n![](https://media.vlpt.us/images/nsunny0908/post/63869434-a7fc-4f5c-bafc-0ea82357ec83/image.png)\n\n- 감쇠 : 긴 케이블을 지나는 동안 신호가 약해진다.\n\n→ 해결법: 증폭 처리를 해주는 기계를 중간에 설치함.\n\n![](https://media.vlpt.us/images/nsunny0908/post/02d6a47a-b4e6-48b9-adf9-19cff13d0f31/image.png)\n\n- 노이즈 : 외부 요인(고온 물체, 또다른 신호를 보내는 케이블, 번개) 에 의해 신호의 형태가 무너진다.\n\n→ 해결법: 노이즈 원인으로부터 케이블을 멀리 두거나 케이블에 특수 가공을 해서 신호가 무너지지 않게 막는다.\n\n![](https://media.vlpt.us/images/nsunny0908/post/c73ae80c-c831-44ba-9dc5-8a7230f5b27a/image.png)\n\n- 충돌 : 멀티액세스 네트워크에서 일어날 수 있는 현상, 신호가 보내지고 있는 도중에 다른 신호를 보내는 경우 발생\n- 멀티액세스 네트워크: 케이블 한 개에 여러대의 컴퓨터를 연결한 구조\n\n→ 해결법: CSMA/CD 라는 액세스 제어를 시행해 신호를 보내는 타이밍을 겹치지 않게 함.\n\n---\n\n## 리피터\n\n![](https://media.vlpt.us/images/nsunny0908/post/18383ee2-e1fe-41f4-b086-d3692263d056/image.png)\n![](https://media.vlpt.us/images/nsunny0908/post/4aa0d234-f2ce-4a25-bc91-75659d5d2eed/image.png)\n\n- 약해진 신호를 증폭시켜 전달한다.\n- 오로지 증폭의 기능만 한다.\n\n## 허브\n\n![](https://media.vlpt.us/images/nsunny0908/post/315985ac-e16e-46d9-8896-402b5f5fa8bf/image.png)\n\n- 다중 포트 리피터\n- 쉽게 말해 리피터의 역할을 하는데 포트가 여러개.\n\n**기능**\n\n1. 약해진 신호를 증폭시켜 전달한다.\n2. 여러개의 기기를 연결해 네트워크를 구축한다.\n\n![](https://media.vlpt.us/images/nsunny0908/post/8d533456-6c46-4de0-b1f9-815084744c4f/image.png)\n\n하나의 케이블 사용\n\n![](https://media.vlpt.us/images/nsunny0908/post/41244c30-6d17-488b-9bca-8ea35d74a92f/image.png)\n\n허브 사용\n\n- 허브와 허브를 연결할 수도 있다. → 큰 네트워크 형성 가능\n\n### 플러딩 (넘쳐흐르다)\n\n![](https://media.vlpt.us/images/nsunny0908/post/11ec8e4a-4bce-4086-b958-9f3bf49c7df5/image.png)\n\n- 허브는 한 컴퓨터에서 전송된 데이터를 모든 컴퓨터에게 다 전송한다. 이를 플러딩이라고 한다.\n- 2계층에서 사용하는 스위치, 브릿지 등은 MAC주소(데이터 링크 계층에서 통신을 위한 네트워크 인터페이스에 할당된 고유 식별자)라는 걸 알기때문에 4번에서 1번으로 보내고 싶으면 특정 컴퓨터로만 전송이 가능하다.\n  그러나 1계층에서만 사용하는 허브는 MAC주소를 알지 못하기 때문에 4번에서 전송하면 1,2,3번한테 모두 전송되는 것이다.\n\n![](https://media.vlpt.us/images/nsunny0908/post/1f3f5ce4-50e4-4ba5-a891-163e259d24b9/image.png)\n\n### 충돌 도메인 (collision Domain)\n\n- 허브로 연결되어 있는 컴퓨터는 같은 충돌 도메인에 있게 된다.\n- 충돌 도메인은 작아야만 하며, 충돌 도메인이 작으려면 연결된 컴퓨터의 수가 적어야 한다.\n- 그러나 반드시 다수의 컴퓨터가 필요한 경우에는 스위치를 사용한다.\n\n## 📝 정리\n\n1. 물리계층은 통신매체를 통해 신호를 전달하는 역할을 한다.\n2. 신호를 전달할 때 감쇠, 노이즈, 충돌 등의 문제가 있을 수 있다.\n3. 물리계층에선 신호를 증폭시키는 역할을 하는 리피터, 증폭시키고 여러개의 기기를 연결할 수 있는 허브를 사용한다.\n"},{"excerpt":"문제상황 Tooltip에 mouse hover할때마다 스크롤이 빠르게 생겼다 사라졌다. overflow hidden인데도 아래와 같은 현상이 발생되었다.  원인 확실하진 않지만, hover 할때마다 x, y의 위치를 계산해 modal을 띄워주고 있는데, hover 속도에 비해 위치 계산하는 로직이 늦게 실행되기 때문인 것 같다. 해결법 setTimeOut…","fields":{"slug":"/contents/posts/2022-03-13/"},"frontmatter":{"date":"March 13, 2022","title":"Tooltip component 트러블 슈팅"},"rawMarkdownBody":"\n# 문제상황\n\n> Tooltip에 mouse hover할때마다 스크롤이 빠르게 생겼다 사라졌다.  \n> overflow hidden인데도 아래와 같은 현상이 발생되었다.\n\n![](https://images.velog.io/images/nsunny0908/post/6e057e9c-c6b1-43c7-b66b-4619554281ad/2022-02-24_16.36.03.gif)\n\n# 원인\n\n확실하진 않지만, hover 할때마다 x, y의 위치를 계산해 modal을 띄워주고 있는데, hover 속도에 비해 위치 계산하는 로직이 늦게 실행되기 때문인 것 같다.\n\n```ts\nconst openTooltip = () => {\n  setIsHover(true)\n}\n\nconst closeTooltip = () => {\n  setIsHover(false)\n}\n\nuseEffect(() => {\n  if (!anchorRef.current || !contentRef.current) {\n    return\n  }\n  const anchorRect = anchorRef.current.getBoundingClientRect()\n  const contentRect = contentRef.current.getBoundingClientRect()\n\n  const { x, y } = calcAnchorCoord({\n    anchorRect,\n    contentRect,\n    anchorOrigin,\n    transformOrigin,\n    anchorPosition,\n  })\n\n  contentRef.current.style.left = `${x}px`\n  contentRef.current.style.top = `${y}px`\n}, [isHover])\n```\n\n# 해결법\n\n- setTimeOut\n\ntooltip을 open시에 스크롤이 생겼다 사라지므로 setIsHover(true)를 setTimeout으로 감싸주었더니 해결되었다.\n\n```tsx\nconst openTooltip = () => {\n  setTimeout(() => {\n    setIsHover(true)\n  })\n}\n```\n\n그렇지만, setTimeout으로 해결하는 것은 왠지 꼼수(?)같은 느낌이 들어, 다른 방법을 찾아 헤맸다.\n\n- useLayoutEffect\n\n위치 계산 하는 로직에 useEffect 대신 useLayoutEffect를 사용하니 문제가 해결되었다.\n\n```ts\nuseLayoutEffect(() => {\n  if (!anchorRef.current || !contentRef.current) {\n    return\n  }\n  const anchorRect = anchorRef.current.getBoundingClientRect()\n  const contentRect = contentRef.current.getBoundingClientRect()\n\n  const { x, y } = calcAnchorCoord({\n    anchorRect,\n    contentRect,\n    anchorOrigin,\n    transformOrigin,\n    anchorPosition,\n  })\n\n  contentRef.current.style.left = `${x}px`\n  contentRef.current.style.top = `${y}px`\n}, [isHover])\n```\n\n# useEffect vs useLayoutEffect\n\n### useEffect\n\n- 컴포넌트들이 render(DOM Tree를 구성하기 위해 각 element의 스타일 속성을 계산하는 과정)와 paint(실제 스크린에 Layout을 표시하고 업데이트하는 과정)된 후 실행된다.  \n  비동기적으로 실행된다.  \n  paint된 후 실행되기 때문에, useEffect 내부에 dom에 영향을 주는 코드가 있을 경우 사용자 입장에서는 화면의 깜빡임을 보게될 수 있다.\n\n### useLayoutEffect\n\nhttps://ko.reactjs.org/docs/hooks-reference.html#uselayouteffect\n\n- 컴포넌트들이 render된 후 실행되며, 그 이후에 paint가 된다.  \n  동기적으로 실행된다.  \n  paint가 되기전에 실행되기 때문에 dom을 조작하는 코드가 존재하더라도 사용자는 깜빡임을 경험하지 않는다.\n\n이러한 useEffect와 useLayoutEffect의 차이점 때문에\nuseEffect를 사용했을 땐, tooltip을 마우스오버했을때 깜빡거리며 스크롤이 생겼다 사라지는 현상이 나타났고 useLayoutEffect을 사용하니 문제가 해결되었던 것 같다.\n\n### setTimeOut으로 해결되었던 이유는?\n\n![](https://images.velog.io/images/nsunny0908/post/2e426cdf-0868-4f9c-b840-dc7e74f48361/image.png)\n\n내 예상으로는 호출스택에 쌓여있던 모든 것들이 처리되고 난 후에 밑의 코드가 실행되었기 때문..? 🤔\n"},{"excerpt":"요구조건 select에 placeholder를 적용해주세요.  문제점 select가 input 태그로 구현되어있었다면 placeholder속성만 넣으면 간단히 해결 됐겠지만, select는 구현체가 였다. div에 placeholder를 어떻게 적용할 수 있을까? div에 placeholder 적용하기 우선 div로 구현되어있는 컴포넌트에 placehol…","fields":{"slug":"/contents/posts/2022-02-28/"},"frontmatter":{"date":"February 28, 2022","title":"div에서 placeholder 사용하기 (styled-component)"},"rawMarkdownBody":"\n# 요구조건\n\n> select에 placeholder를 적용해주세요.\n\n![](https://images.velog.io/images/nsunny0908/post/2c2da547-a6a9-4265-9b3c-1672b2c0f61a/image.png)\n\n# 문제점\n\nselect가 input 태그로 구현되어있었다면 placeholder속성만 넣으면 간단히 해결 됐겠지만, select는 구현체가 `div`였다.\n\ndiv에 placeholder를 어떻게 적용할 수 있을까?\n\n# div에 placeholder 적용하기\n\n```tsx\n<Select placeholder={placeholder} />\n```\n\n- 우선 div로 구현되어있는 컴포넌트에 placeholder 속성을 넣어준다. (속성 이름은 꼭 placeholder가 아니어도 된다.)\n\n```tsx\n<Select placeholder={placeholder} hasValue={!!value} />\n```\n\n- placeholder는 select에 값이 선택되면 사라져야하므로, `hasValue` 란 prop을 넘겨준다.\n\n```tsx\n${({ hasValue, placeholder }) =>\n    !hasValue &&\n    placeholder &&\n    css`\n      &:before {\n        content: attr(placeholder);\n        color: gray;\n      }\n    `}\n```\n\n- hasValue가 없으면서 placeholder가 있을때만 보여야하므로 styled-component 내에서 분기처리를 한다.\n\n- 가상요소 `before`와 속성을 가져오는 함수인 `attr`을 이용해 placeholder를 적용한다.\n\n![](https://images.velog.io/images/nsunny0908/post/04e64252-1da5-4b07-9ffb-87d60e762276/image.png)\n\n![](https://images.velog.io/images/nsunny0908/post/c5bf4953-4bf7-4ad5-b1b9-b4ff1ea477db/image.png)\n\n- 하지만 select의 영역을 다 차지하는 것이 아니라 일부만 차지하고 있다.\n\n```tsx\n${({ hasValue, placeholder }) =>\n    !hasValue &&\n    placeholder &&\n    css`\n      &:before {\n        content: attr(placeholder);\n        color: gray;\n        white-space: nowrap;\n        width: 100%;\n      }\n    `}\n```\n\n- 해결을 위해 width에 100%값을 주고, white-space: nowrap; 속성을 추가한다.\n\n![](https://images.velog.io/images/nsunny0908/post/f5c9f42d-3241-4cb4-bb6c-c302fda6200f/image.png)\n\n# ::before\n\n### ::before\n\n> ::before는 선택한 요소의 첫 자식으로 요소를 생성한다.\n\n예를 들어서 설명하자면, 다음과 같은 span태그가 있다고 하자.\n\n```html\n<span class=\"text\">텍스트</span>\n```\n\n```css\n.text::before {\n  content: \"♥\";\n}\n```\n\nspan 앞에 하트를 추가하면 다음과 같이 보여지게 된다.\n\n![](https://images.velog.io/images/nsunny0908/post/9c582fcd-e8b3-4cb0-b279-a984129d269f/image.png)\n\n# attr()\n\n> `attr()`는 요소의 속성 값을 문자열로 반환하는 함수이다.\n\n요소에 속성 값이 없으면 빈 문자열이 반환된다.\n\n위의 예제에서 placeholder란 속성을 추가하고 내용을 입력해보자.\n\n```html\n<span class=\"text\" placeholder=\"placeholder\">텍스트</span>\n```\n\n```css\n.text::before {\n  content: attr(placeholder);\n}\n```\n\n![](https://images.velog.io/images/nsunny0908/post/2513a172-3a8f-4710-a743-0eaa251d4801/image.png)\n\nplaceholder의 내용을 가져올 수 있다.\n"},{"excerpt":"요구조건 search input이 focus될때 inputContainer div와 icon의 색을 바꿔주세요.  SearchInput의 구조 SearchInput을 사용하는 곳의 구조 처음 시도한 방법 상위 container div가 아닌 input 자체에 border가 먹게 됨.  :focus-within 포커스를 받았거나, 포커스를 받은 요소를 포함…","fields":{"slug":"/contents/posts/2022-01-05/"},"frontmatter":{"date":"January 05, 2022","title":":focus-within"},"rawMarkdownBody":"\n# 요구조건\n\n> search input이 focus될때 inputContainer div와 icon의 색을 바꿔주세요.\n\n![](https://images.velog.io/images/nsunny0908/post/a2ff9b31-8cea-4d66-a4d2-b9c3117e9fe6/Untitled.png)\n\n# SearchInput의 구조\n\n```tsx\n<SearchInputContainer {...rest}>\n  <Input\n    ref={inputRef}\n    ...\n  />\n  <SearchIcon onClick={handleIconClick}>\n    <Icon icon=\"search\" />\n  </SearchIcon>\n</SearchInputContainer>\n```\n\n# SearchInput을 사용하는 곳의 구조\n\n```tsx\n<SearchInputContainer>\n  <SearchInputOverride onChange={handleSearchInputChange} />\n</SearchInputContainer>\n```\n\n# 처음 시도한 방법\n\n```tsx\nconst SearchInputOverride = styled(SearchInput)`\n  & input:focus {\n    border: 1px solid blue;\n\n    & + span > i {\n      border: 1px solid blue;\n    }\n  }\n\n  & span i {\n    color: gray;\n  }\n`\n```\n\n- 상위 container div가 아닌 input 자체에 border가 먹게 됨.\n\n![](https://images.velog.io/images/nsunny0908/post/cb7c51f3-f4a6-45aa-b9a3-aed7df500c69/Untitled-1.png)\n\n# :focus-within\n\n> [포커스를 받았거나, 포커스를 받은 요소를 포함하는 요소를 선택해주는 선택자](https://developer.mozilla.org/ko/docs/Web/CSS/:focus-within)\n\n![](https://images.velog.io/images/nsunny0908/post/cb7c51f3-f4a6-45aa-b9a3-aed7df500c69/Untitled-1.png)\n\n```tsx\nconst SearchInputContainer = styled(\"div\")`\n  & div:focus-within {\n    border: 1px solid blue;\n\n    & span i {\n      color: blue;\n    }\n  }\n\n  & span i {\n    color: gray;\n  }\n`\n```\n\n- 포커스를 받은 input의 부모인 SearchInputContainer에서 `:focus-within` 선택자를 사용해 스타일을 넣어주었다.\n"},{"excerpt":"🌪 정리하지 않고 넘어가기엔 너무 많은 일들이 있었다. 이 글은 돌풍과도 같았던 2021년 한해를 정리하는 글이다. 💥 부트캠프 백앤드 개발자로 약 두 달 가량 일하던 모 중소기업에서 퇴사를 하고 더 적성에 맞는 프론트앤드 개발자가 되기 위해 부트캠프에 참여했다. 자세한 내용은 부트캠프 수료 후 일기에 작성했기 때문에 길게 이야기하지는 않으려고 한다. 솔…","fields":{"slug":"/contents/posts/2021-12-31/"},"frontmatter":{"date":"December 31, 2021","title":"2021년 회고"},"rawMarkdownBody":"\n## 🌪\n\n정리하지 않고 넘어가기엔 너무 많은 일들이 있었다.  \n이 글은 돌풍과도 같았던 2021년 한해를 정리하는 글이다.\n\n---\n\n## 💥 부트캠프\n\n백앤드 개발자로 약 두 달 가량 일하던 모 중소기업에서 퇴사를 하고 더 적성에 맞는 프론트앤드 개발자가 되기 위해 부트캠프에 참여했다.  \n자세한 내용은 부트캠프 수료 후 일기에 작성했기 때문에 길게 이야기하지는 않으려고 한다.  \n솔직히 부트캠프 자체가 100% 만족은 아니지만 언제나 내가 그랬듯, 후회보다는 그 선택이 그때의 최선의 선택이겠지- 라고 생각하려고 한다.\n\n---\n\n## 🙋🏻‍♀️ 취준\n\n취준기간에 오히려 부트캠프 다닐때보다 내 스스로가 많이 성장했다고 느꼈다.  \n기업에서 내 준 과제를 혼자 끙끙대며 해결하고 면접 질문을 정리하고 꼬리질문에 대비했다. (물론 아직 한참 부족하다.)  \n'수료하면 무조건 취업 가능합니다!'라는 부트캠프의 달콤한 말이 거짓인줄은 알았지만 나에게 취준기간은 꽤 쓴 맛이었다.  \n대놓고 무시를 당하기도 하고 면접질문의 반 이상을 대답하지 못한 적도 있다.  \n그래도 기 죽지는 않았다. 거기서 기까지 죽으면 정말 끝이니까 틀린 답을 말하더라도 내가 정답인것마냥 자신감 하나로 부딫혔었던 것 같다.  \n스스로 발표 공포증이 있다고 생각할 만큼 나서서 많은 사람들 앞에서 이야기를 하는 것에 두려움이 있었던 내가\n면접이 하나씩 끝날때마다 조금씩 성장한다는 게 느껴졌다.  \n결국 약 8개 기업에서 최종오퍼를 받았고 제일 마지막에 면접을 봤던 현재 회사에 입사하게 되었다. 🥳\n\n---\n\n## 💤 휴식\n\n5개월 내내 쉼없이 달려왔기에 입사 전에 꼭 휴식이 필요하다고 느꼈다.  \n2주 정도를 쉬었는데 혼자 여행이라도 갈까 하다가 코로나 확진자수가 급격하게 증가해서 여행은 못가게 되었다.  \n먹고 자고 올림픽보고 정말 원없이 충전했다.\n\n---\n\n## 🕴🏻 입사\n\n![](https://images.velog.io/images/nsunny0908/post/df0d1f0e-7dc9-47ac-9ef9-680b4ab1ab3c/0594d5dee2882f7638390660def97572361fc6a2.gif)\n\n입사 후 한달동안 OJT기간을 가졌다.  \n기존의 회사 코드를 보기도 하고 필요한 학습을 하기도 하고 작은 테스크들을 처리하기도 했다.  \n'잘' 질문하는게 어렵다는 걸 느꼈다. 어디서부터 막혔는지도 모를만큼 그냥 아예 깜깜하고 막막한 상태일 때가 더 많았다.  \n내가 하기로 한 테스크를 도저히 못할 것 같아 팀원분들께 도움을 요청하기도 했었다.  \n다행히 뭐라고 하는 분들은 없었지만 내가 무능하다고 느껴져 좌절하기도 했다.  \n팀원분들은 잘하고 있다고 이야기해주셨지만 내가 내 스스로를 끊임없이 의심했다.  \n매분 매초를 수습 통과하지 못하면 어떡하지? 이런 전전긍긍 속에서 산 것은 아니지만 문득문득, 내가 지금 잘하고 있는걸까? 란 불안감이 파도처럼 나를 덮쳤다.  \n안정되면 주니어가 아니지. 불안감을 안고 그냥 내가 할 수 있는 것들을 하자.  \n다행히 수습을 통과했다.  \n내년엔 1인분 하는 팀원이 되고 싶다 제발.\n\n---\n\n## 👩🏻‍💻 업무\n\n10월쯤 부터 통합 백오피스 구축을 위한 기획이 시작되었다.  \n그동안은 레거시 프로젝트를 진행했었는데 통합 백오피스 프로젝트가 시작되면서 프로젝트를 초기부터 셋팅해나갔다.  \n첫째로 프론트앤드에 모노레포를 도입하기로 했으며, mui를 걷어내고 독자적인 디자인시스템을 만들어나가기로 했다.  \n예전부터 해보고싶었던 것 중에 하나라 걱정이 되기도 하는 한 편, 기대도 됐었던 것 같다.  \n공통 컴포넌트를 제작하면서 컴포넌트 설계에 대한 이야기를 팀원들과 자주 나눴었고,\n개인적인 성장에 있어서도 도움이 많이 되었다고 생각한다.  \n첫번째 마일스톤의 마무리 즈음, 팀원분께서 감사하게도 프론트 세션을 열어주셔서 컴포넌트의 합성과 상속에 있어서 고민했던 것들이 명확해지는 계기도 되었다.\n\n---\n\n## 📙 스터디\n\n어느정도 회사에 적응하고나서는 퇴근하고 아무것도 하기 싫어서 누워만 있는 일상이 지속되었다.  \n더이상 이렇게 허송세월을 보내면 안될 것 같단 생각에 스터디를 구하기 시작했다.  \n프론트앤드 스터디, Nodejs스터디 총 두개의 스터디를 시작했다.  \n공부가 목적이긴 하지만 스터디 주제가 재미가 없으면 끝까지 하기 싫을 것 같아서 내 관심사 위주의 스터디를 구했다.  \n프론트앤드 스터디는 프론트앤드 개발환경에 대한 강의를 듣고 목차 하나씩을 정해 각자 발표를 진행하는 스터디다.  \n이외에 각자 회사에서 겪었던 트러블슈팅에 관한 경험을 공유하고 자유롭게 이야기 나누기도 한다.  \n우리 회사 말고 다른 회사는 어떤식으로 일을 하는지, 나와 비슷한 주니어 프론트 개발자들은 어떤 생각을 가지고 있는지가 궁금했는데 이 스터디를 진행하면서 많은 부분이 상당수 해소되었다.  \n기한이 정해져있지 않은 스터디라서 최대한 오래 하고 싶단 마음이 크다.  \nNodejs 스터디는 평소에 노드를 해보고싶었지만 지금 당장 내가 하는 것도 아닌데.. 하면서 미뤄두다가 스터디 구인 글을 보고 이번에야말로 진짜 해보자! 해서 시작하게 되었다.  \n노드 강의를 듣고 각자 정리한 것을 발표하고 공유하는 4주짜리의 짧은 스터디라 부담이 덜할 것 같아서였다.  \n확실히 퇴근 후와 주말에 공부한다는 게 힘이 들지만 의미없게 쉬는 날을 낭비하는 느낌이 덜해서 좋았다.\n\n---\n\n## 💪🏻 건강\n\n입사 초기에 정신없어서 그만뒀던 운동을 다시 시작했다.  \n수습이 끝나면서 건강증진 복지혜택을 받을 수 있게 되어서 법카로 냅다 PT와 필라테스를 질러버렸다(감사합니다🙇🏻‍♀️).  \n그래도 운동을 꾸준히 했다고 생각했는데 몇달 쉬니까 근손실이.... 🥲  \n그래도 예전처럼 코어가 심각하게 부족해서 운동을 아예 할 수 조차 없는 상황은 아니여서 그나마 다행이였다.  \n건강하자 제발\n\n---\n\n## 👾 자격증\n\n![](https://images.velog.io/images/nsunny0908/post/c04ce57f-d593-4a17-9194-ec4e3d921672/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-01-03%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2012.57.42.png)\n\n숙제처럼 미뤄두고 있던 정보처리기사 자격증을 취득했다.  \n필기는 작년에 땄는데 실기를 계속 미루다가 계속 미루면 평생 못딸 것 같단 생각이 들어 공부를 시작했다.  \n제일 힘들었던 건 퇴근 후의 지친 몸을 이끌고 책상에 앉아야한다는 그 자체였다.🥲  \n업무적으로 아주 필요성이 있는 건 아니였지만 그래도 미뤄두던 걸 해치웠다는 성취감이 들었다.  \n이력서에 뭐라도 작성하려고 정보처리기사 필기합을 써놨던(ㅋㅋ) 과거는 이제 안녕👋🏻\n\n---\n\n## ✍🏻 기록\n\n![](https://images.velog.io/images/nsunny0908/post/fd9bc52d-b72a-4f52-891a-6863c923c509/image.png)\n\n일상블로그를 시작했다.  \n그냥 친구들이 하길래 따라 시작했는데 생각보다 내 일상을 기록하는게 재미있더라.  \n일주일에 한번 꼬박 쓰다가, 요샌 조금 소홀해지고 있는데 느리지만 꾸준히 해 볼 생각이다.  \n내가 가장 힘들어하는 느리지만 꾸준하게를 소소하게나마 지켜나가야지.\n\n---\n\n## 🤍 관심있는 것들\n\n![](https://images.velog.io/images/nsunny0908/post/98834f89-708d-476b-9876-345c4d78f434/8F4DF874-0A0D-4553-AA32-55E12C650C98.png)\n\n언제나 기분 좋은 `Hello world`\n\n12월의 끝자락 주말에 갑자기 svelte를 해보고싶은 마음이 생겨 레포부터 팠다.  \n뭘 할까 하다가 거의 'hello world'급인 투두리스트 만들기를 했다.  \n리액트를 하다 스벨트를 하니까 확실히 쉽고 코드량이 거의 반절 이상은 주는 것 같다.  \n대형프로젝트는 무리일 것 같고 조그만 토이프로젝트를 스벨트로 한 번 해보고싶다.\n\n---\n\n## 👋🏻 welcome 2S22\n\n![](https://images.velog.io/images/nsunny0908/post/7e3f4441-d6f1-4d52-bbb9-547f34757ed7/image.png)\n이번해에 심은 잔디🌱  \n올해 초에 한 해를 맞이하며 계획했던 일들을 그래도 어느정도는 이루었던 한 해인 것 같아서 나름대로 만족스러운 한해였다.  \n그럼에도 아쉬운 것은 같은 시간을 쓰더라도 조금 더 밀도있게 사용하지 못했다는 것?  \n12월에는 재택도 하게 되어서 컨디션 관리가 쉽지 않았고, 1시간이면 끝낼 일을 5-6시간씩 잡고있었던 일도 많았다.  \n잘했던 점은 계획에 너무 매몰되지 않았다는 점. 계획을 세우면 계획이 틀어질때의 스트레스도 오기 마련인데 올해는 그런 강박들을 내려놓는 노력을 했다.  \n확실히 '반드시 지켜야한다'는 부담감이 덜해서 좋았던 것 같다.  \n2022년에도 내가 이루고자 하는 것들을 이룰 수 있는 한해이길 바래본다.\n"},{"excerpt":"프론트앤드 스터디에서 진행한 NPM에 대한 발표자료 NPM  우선, npm에 대해 설명하기 전에 모듈에 대해 좀 짚고 넘어갈 필요성이 있다. 모듈화 📂 모듈 : 애플리케이션을 구성하는 개별적 요소 모듈은 개별적으로 존재하다가 필요에 따라 명시적으로 모듈을 로드해서 사용 가능 → 효율성, 유지보수성 ⬆️ NPM (Node Package Manager) 모듈들…","fields":{"slug":"/contents/posts/2021-12-19/"},"frontmatter":{"date":"December 19, 2021","title":"NPM"},"rawMarkdownBody":"\n> 프론트앤드 스터디에서 진행한 NPM에 대한 발표자료\n\n# NPM\n\n![](https://images.velog.io/images/nsunny0908/post/9dd61da3-b7f5-4953-bb0c-86e68bf85219/image.png)\n\n우선, npm에 대해 설명하기 전에 모듈에 대해 좀 짚고 넘어갈 필요성이 있다.\n\n# 모듈화\n\n> 📂 모듈 : 애플리케이션을 구성하는 개별적 요소  \n> 모듈은 개별적으로 존재하다가 필요에 따라 명시적으로 모듈을 로드해서 사용 가능  \n> → 효율성, 유지보수성 ⬆️\n\n# NPM (Node Package Manager)\n\n- 모듈들을 패키지화하여 모아둔 저장소 역할과 패키지 설치 및 관리 역할\n- npm으로 자신이 작성한 패키지를 배포해서 공개할 수도 있고 필요한 패키지들을 검색해서 사용할 수도 있다.\n\n> 1. 패키지 관리\n> 2. 패키지의 버전관리\n\n# NPM 설치\n\n- 아마 프론트앤드 개발을 하면서 터미널에 가장 많이 작성한 키워드 중에 하나일 것.\n\n- `node.js` 를 설치하면 자동으로 설치\n\n# NPM으로 모듈 다운로드하기\n\n- 옵션을 별도로 지정하지 않으면 지역으로 설치되며, 프로젝트 루트 디렉터리에 `node_modules` 안에 패키지가 설치된다. 지역으로 설치된 패키지는 해당 프로젝트 내에서만 사용할 수 있다.\n\n### 지역설치 (default)\n\n```jsx\nnpm install [packageName]\n```\n\n### 전역설치\n\n전역으로 설치하면 모든 프로젝트에서 사용가능하다.\n\n```jsx\nnpm install -g [packageName]\n```\n\n# Package.json\n\n`npm init`\n\n- 프로젝트에서는 많은 패키지를 사용하게 되고 패키지의 버전도 빈번하게 업데이트되므로 프로젝트가 의존하고 있는 패키지를 일괄 관리할 필요가 있다.  \n  npm은 `package.json` 파일을 통해서 프로젝트 정보와 패키지의 의존성(dependency)을 관리한다. 이미 작성된 package.json이 있다면 팀 내에 배포하여 동일한 개발 환경을 빠르게 구축할 수 있는 장점이 있다.\n\n> 🧾 모듈들의 버전을 명시한 명세서\n\n### dependencies vs devDependencies\n\n![](https://images.velog.io/images/nsunny0908/post/b82c0e34-0f69-4bbb-bde8-df994e39db09/image.png)\n\n- `dependencies` : **프로덕션 환경**에서 응용 프로그램에 필요한 패키지.\n- `devDependencies`: **로컬 개발 및 테스트**에만 필요한 패키지.\n\n### package.json vs package.lock.json\n\n![](https://images.velog.io/images/nsunny0908/post/613b07c0-7ca7-4cd3-88be-e2fef5e2ea6d/image.png)\n\n- `package.json`: version range (버전의 범위를 명시)\n\n> 🌳 개발자들이 서로 같은 node_modules 트리를 갖도록 하는 역할\n\n### scripts\n\n- 우리가 `run` 명령어를 통해서 실행할 것들을 적어두는 것\n\n```json\n\"scripts\": {\n    \"start\": \"npm run dev\",\n\t\t\"hello-world\": \"echo 'Hello World'\",\n    \"prettier\": \"prettier --write --config ./prettier.config.js './src/**/*.{ts,tsx}'\",\n    \"lint\": \"eslint './src/**/*.{ts,tsx,js,jsx}'\",\n    \"lint:fix\": \"eslint --fix './src/**/*.{ts,tsx,js,jsx}'\"\n  },\n```\n\n# NPM 배포하기\n\n1. 배포가 가능한 패키지명인지 확인\n\n```json\nnpm info [packageName]\n```\n\n2. 필요한 정보 입력 (version, description...)\n\n```json\nnpm init\n```\n\n3. 로그인\n\n```json\nnpm login\n```\n\n4. npmignore\n5. 배포\n\n```json\nnpm publish\n```\n\n- 버전관리 (`Semver`: Semantic Versioning)\n\n```json\nnpm version major   # package.json파일 version의 첫 번째 숫자 (v1.0.0 -> v2.0.0)\nnpm version minor   # package.json파일 version의 두 번째 숫자 (v1.0.0 -> v1.1.0)\nnpm version patch   # package.json파일 version의 세 번째 숫자 (v1.0.0 -> v1.0.1)\n```\n\n# NPM vs yarn\n\nnpm을 대응하는 오픈소스 라이브러리 중에는 여러가지가 있는데 그 중에 가장 유명하고 사람들이 많이 사용하는게 `yarn`\n\n### yarn과의 차이점\n\n1. 속도\n   → yarn은 병렬 처리\n\n2. 보안\n   → npm은 의존 관계를 가지는 다른 패키지들이 즉시 포함되도록 한다.\n   반면 yarn은 yarn.lock이나 package.json 파일에 있는 것들만 설치를 한다.\n"},{"excerpt":"popover 컴포넌트에서 Position 값을 받아 방향에 따라 ref의 style값을 조정하는 함수를 만드는 중에 일어난 일이다. 💁🏻‍♂️ : 이거 왜 커스텀훅으로 안만들고 함수로 만드셨나요? 🙍🏻‍♀️(나) : (..) 그래서 정리해보고자 하는 글! 어떨 때 우리는 custom hook을 사용하고 어떨 때 함수를 사용해야하는 걸까? Custom hook이란? 반…","fields":{"slug":"/contents/posts/2021-11-25/"},"frontmatter":{"date":"November 25, 2021","title":"Custom hook vs Function"},"rawMarkdownBody":"\n> popover 컴포넌트에서 Position 값을 받아 방향에 따라 ref의 style값을 조정하는 함수를 만드는 중에 일어난 일이다.  \n> 💁🏻‍♂️ : 이거 왜 커스텀훅으로 안만들고 함수로 만드셨나요?  \n> 🙍🏻‍♀️(나) : (..)  \n> 그래서 정리해보고자 하는 글!  \n> 어떨 때 우리는 custom hook을 사용하고 어떨 때 함수를 사용해야하는 걸까?\n\n# Custom hook이란?\n\n반복되는 훅 활용 코드들을 자신만의 hook으로 만들어서 컴포넌트 로직을 함수로 뽑아내어 재사용할 수 있는 것.  \ncustom hook의 이름은 무조건 `use`로 시작해야한다.\n(ex. useForm ..)\n\n# 어떨때 Custom hook을 사용하면 좋을까?\n\n1. DOM에 대한 직접적인 조작이 있을때\n2. 사이드 이펙트가 있을때 (useRef, useEffect …)\n3. 상태값을 가질때\n\n# function 으로 만든 이유\n\n1. 최상단에서 호출되므로 close일때도 훅이 호출된다.\n2. 파라미터를 전달받고 x, y값을 리턴하는 용도로만 사용되므로 순수함수에 가깝다.  \n   (동일한 파라미터를 전달했을때 동일한 return값이 나온다.)\n\n# 결론\n\n무조건 커스텀훅으로 만들지 말고 일반 함수로도 충분하다면 일반 함수로 만들자.\n"},{"excerpt":"외부 라이브러리를 입맛대로 바꾸기 위해 간단하게 patch-package 라이브러리를 사용해보았다. 설치 npm 또는 yarn을 이용해 설치한다. 난 yarn을 쓰기 때문에 yarn으로 설치해주었다.  postinstall 설치하는 이유 yarn은 postinstall hook을 ,  후에만 실행한다.\n후에도 확실하게 postinstall hook을 사용…","fields":{"slug":"/contents/posts/2021-10-05/"},"frontmatter":{"date":"October 05, 2021","title":"patch-package로 외부 라이브러리 수정해서 사용하기"},"rawMarkdownBody":"\n> 외부 라이브러리를 입맛대로 바꾸기 위해 간단하게 patch-package 라이브러리를 사용해보았다.\n\n# 설치\n\nnpm 또는 yarn을 이용해 설치한다. 난 yarn을 쓰기 때문에 yarn으로 설치해주었다.\n\n`yarn add patch-package postinstall-postinstall`\n\n## postinstall 설치하는 이유\n\nyarn은 postinstall hook을 `yarn`, `yarn add` 후에만 실행한다.\n`yarn remove`후에도 확실하게 postinstall hook을 사용하기 위해 설치해준다.  \n[GitHub - ds300/patch-package: Fix broken node modules instantly](https://github.com/ds300/patch-package#why-use-postinstall-postinstall-with-yarn)\n\n- postinstall 이란?\n  패키지의 종속성 트리 변경 사항이 디스크에 기록되면(예: 종속성 또는 전이적 종속성이 추가, 제거 또는 변경된 후) 호출되는 yarn lifecycle script\n\n> postinstall is called after a package's dependency tree changes are written to the disk -- e.g. after a dependency or transitive dependency is added, removed, or changed.\n> It is guaranteed to be called in topological order (in other words, your dependencies' postinstalls will always run before yours).\n> For backwards compatibility, preinstall and install are called as part of postinstall.\n\n설치를 해주었다면 `package.json` script에 다음과 같이 등록한다.\n\n```\n “scripts”: {\n  “postinstall”: “patch-package”\n }\n```\n\n#\n\nnode_modules 안에 외부 라이브러리 수정이 끝나면\n\n`yarn postinstall 라이브러리이름`\n\n명령어로 변경사항을 저장할 수 있다.\n\n![](https://images.velog.io/images/nsunny0908/post/5a51ed43-d000-45d3-964e-2753d78fd70e/F8B409DA-B7DA-4D2A-AC73-0BDF4E88161C.png)\n\n## ‘dependencies’ of undefined\n\n혹시 이 과정에서\n\n```\nTypeError: Cannot read property ‘dependencies’ of undefined\n```\n\n다음과 같은 에러가 발생한다면 `package.lock.json`, `yarn.lock` 파일을 삭제하고 다시 `yarn`후에 `yarn postinstall 라이브러리이름` 과정을 다시 해주면 된다.\n나도 같은 에러가 발생했는데 `package.lock.json`에 patch-package 가 없어서 해당 에러가 발생했다.  \n([Make patch fails on package lock file dependencies check. · Issue #164 · ds300/patch-package · GitHub](https://github.com/ds300/patch-package/issues/164))\n\n![](https://images.velog.io/images/nsunny0908/post/b8f1f685-f403-40d4-9eea-d8093599396a/BBAC01FD-F3A0-4672-B3DC-89DF820F6C20.png)\n\n해당 과정까지 마치면 라이브러리의 변경사항이 변경된 파일로 올라와있는 것을 볼 수 있다.\n"},{"excerpt":"폴더의 depth가 깊어질수록 import시에 경로를 작성하는데 매우 귀찮고 코드도 깔끔해보이지 않다. 그럴때 Alias 설정을 해 간결하게 작성할 수 있다. Alias설정 우선 tsconfig.json에 compilerOptions에 path를 지정한다.  Module resolver 설치와 babelrc 설정 지금 현재 프로젝트는 js와 ts가 혼재되…","fields":{"slug":"/contents/posts/2021-09-09/"},"frontmatter":{"date":"September 09, 2021","title":"Typescript Alias 설정시 마주친 오류"},"rawMarkdownBody":"> 폴더의 depth가 깊어질수록 import시에 경로를 작성하는데 매우 귀찮고 코드도 깔끔해보이지 않다. 그럴때 Alias 설정을 해 간결하게 작성할 수 있다.\n\n```js\n//bad\nimport Button from '../../../Common/Button'\n\n//good\nimport Button from '@/Common/Button'\n```\n\n# Alias설정\n\n우선 tsconfig.json에 compilerOptions에 path를 지정한다.\n\n`tsconfig.json`\n```json\n{\n\t\"compilerOptions\": {\n\t\t...\n\t\t\"baseUrl\": \".\",\n\t\t\"paths\": {\n\t\t\t\"@/*\": [\"src/*\"],\n\t\t}\n\t}\n}\n```\n\n# Module resolver 설치와 babelrc 설정\n지금 현재 프로젝트는 js와 ts가 혼재되어있기 때문에 tsconfig에만 설정하면 js에서는 불러오지 못하는 이슈가 있어 babel module resolver를 설치해주었다.\n```\nyarn add --dev babel-plugin-module-resolver\n```\n\n설치 후, .babelrc에 설정을 추가한다.\n\n`.babelrc`\n```json\n{\n  ...\n  \"plugins\": [\n    [\n      \"module-resolver\",\n      {\n        \"root\": [\"./\"],\n        \"alias\": {\n            \"@\": \"./src/\"\n        }\n      }\n    ]\n  ]\n}\n```\n\n# 문제\n여기까지 설정했는데 ts파일에서는 Alias가 제대로 적용이 되었으나 js에서는 import시 자동완성이 되지 않는 문제가 발생했다.   \n해결을 위해 jsconfig.json를 만들고 설정해주기로 했다.\n\n`jsconfig.json`\n\n```json\n{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"target\": \"es6\",\n    \"baseUrl\": \"./\",\n    \"paths\": {\n      \"@/*\": [\"src/*\"],\n    },\n    \"allowSyntheticDefaultImports\": true\n},\n\"exclude\": [\n  \"node_modules\",\n],\n  \"include\": [\n    \"**/*.js\",\n    \"**/*.jsx\"\n  ]\n}\n```\n\n하지만 여전히 해결이 되지 않았다.   \n알고보니 jsconfig와 tsconfig를 같이 사용할때는 필연적으로 하나의 config만 본다는 사실을 알게되었다. (해당이슈 : https://github.com/microsoft/TypeScript/issues/15869)   \n현재 js파일이 tsconfig를 보고 있으니 tsconfig에 includes에\n.js, jsx를 추가해주자!\n\n# tsconfig include 설정\n\n```json\n \"include\": [\n   \"**/*.d.ts\",\n   \"**/*.ts\",\n   \"**/*.tsx\",\n   \"**/*.js\",\n   \"**/*.jsx\"\n  ]\n```\n\n   js, jsx를 추가해주었더니 ts, js파일에서 모두 import시 자동완성을 사용할 수 있었다."},{"excerpt":"회사프로젝트에 시범적으로 VAC패턴을 도입하기로 결정했다. 근데 VAC패턴이 뭐지?🤔 디자인패턴 우선 VAC패턴에 대해 이야기하기 전에 디자인패턴에 대한 대략적인 이해가 필요하다.\n디자인패턴은 아주 간단하게 말해 이다. 여러명의 개발자가 하나의 프로젝트를 할 때 각각의 기준에 따라 중구난방으로 설계하면\n효율적인 코드를 짜기 어려울 것이다. 설계적 문제점을…","fields":{"slug":"/contents/posts/2021-09-04/"},"frontmatter":{"date":"September 04, 2021","title":"VAC 패턴"},"rawMarkdownBody":"\n> 회사프로젝트에 시범적으로 VAC패턴을 도입하기로 결정했다. 근데 VAC패턴이 뭐지?🤔\n\n# 디자인패턴\n\n우선 VAC패턴에 대해 이야기하기 전에 디자인패턴에 대한 대략적인 이해가 필요하다.\n디자인패턴은 아주 간단하게 말해 `설계 패턴`이다.  \n여러명의 개발자가 하나의 프로젝트를 할 때 각각의 기준에 따라 중구난방으로 설계하면\n효율적인 코드를 짜기 어려울 것이다.  \n설계적 문제점을 해결하고 여러 사람들이 쉽게 알아볼 수 있도록 하는 설계적 약속이 바로 디자인패턴이다.\n\n# VAC패턴을 도입하게 된 이유\n\n그렇다면 우리는 왜! VAC패턴을 도입하기로 결정했을까?  \n우리 회사의 프론트팀은 리액트 환경에서 비즈니스 로직과 View의 관심사를 어떻게 하면 분리할 수 있을까에 대한 고민이 많았다.  \n버튼을 누르면 숫자가 증가하는 페이지를 개발자와 UI/UX디자이너가 함께 작업한다고 가정해보자.  \n비즈니스 로직과 View가 한군데에 모여있다면, UI/UX디자이너와 개발자가 JSX를 같이 관리해야하기 때문에 UI/UX디자이너가 JSX를 수정하는것이 쉽지 않고 컨플릭이 발생할 확률이 높아진다.\n\n# VAC패턴 (View Asset Component)\n\nVAC 패턴은 View 컴포넌트에서 JSX 영역을 Props Object로 추상화하고, 비즈니스 로직컴포넌트와 View 컴포넌트를 따로 관리한다.\n\n![](https://media.vlpt.us/images/kangkyeungseok/post/062cb3f6-81a0-4644-b160-64e4179461fb/image.png)\n\n# 사용해보기\n\ninput에 입력한 값을 옆에 나타내는 간단한 예제가 있다.\n먼저 vac패턴을 적용하지 않은 App.js이다.\n\n```jsx\nexport default function App() {\n  const [value, setValue] = useState(\"\")\n\n  const handleInput = (e) => {\n    setValue(e.target.value)\n  }\n\n  return (\n    <div>\n      <input type=\"text\" onChange={(e) => handleInput(e)} />\n      <span>{value}</span>\n    </div>\n  )\n}\n```\n\n## vac패턴 사용시\n\n`App.js`\n\n```jsx\nexport default function App() {\n  const [value, setValue] = useState(\"\")\n\n  const handleInput = (e) => {\n    setValue(e.target.value)\n  }\n\n  const props = {\n    value,\n    handleInput,\n  }\n\n  return <AppView {...props} />\n}\n```\n\nview에서 필요한 모든 데이터를 props의 형태로 view영역에 전달한다.\n\n`App.view.js`\n\n```jsx\nconst AppView = ({ value, handleInput }) => {\n  return (\n    <div>\n      <input type=\"text\" onChange={(e) => handleInput(e)} />\n      <span>{value}</span>\n    </div>\n  )\n}\n\nexport default AppView\n```\n\nVAC패턴의 가장 큰 장점은 관심사가 분리되어있다는 것이다.  \ninput의 디자인이 변경될 경우 View영역만 보면 되고, 비즈니스 로직이 변경될 경우 비즈니스 로직을 담당하는 영역만 보면 되기 때문이다.\n\n## 마무리\n\n아직 VAC패턴을 도입하는 초기 단계이기 때문에 아주 간단하게 블로깅해보았다. 이렇게 저렇게 사용해보면서 느껴지는 점들이나 참고해야할 점들을 추가할 예정이다!✨\n"},{"excerpt":"자바스크립트는 기본적으로 모든 선언을 호이스팅한다. 하지만 은 선언 이전에 참조하면 참조에러가 발생한다. 그 이유는 바로 일시적 사각지대 때문이다. TDZ(Temporal Dead Zone) 일시적인 사각지대.  스코프의 시작 지점부터 초기화 시작 지점까지의 구간 변수 선언의 3단계 javascript에서의 변수는 위의 사진처럼 , , 이라는 3단계에 걸…","fields":{"slug":"/contents/posts/2021-08-30/"},"frontmatter":{"date":"August 30, 2021","title":"TDZ (Temporal Dead Zone)"},"rawMarkdownBody":"\n> 자바스크립트는 기본적으로 모든 선언을 호이스팅한다. 하지만 `let`은 선언 이전에 참조하면 참조에러가 발생한다. 그 이유는 바로 일시적 사각지대 때문이다.\n\n# TDZ(Temporal Dead Zone)\n\n> 일시적인 사각지대.  \n>  스코프의 시작 지점부터 초기화 시작 지점까지의 구간\n\n# 변수 선언의 3단계\n\njavascript에서의 변수는 위의 사진처럼 `선언(Declaration phase)`, `초기화(Initialization phase)`, `할당(Assignment phase)`이라는 3단계에 걸쳐서 생성된다.\n\n![](https://dmitripavlutin.com/static/ca6269b32115dd32ebe631dd8293298a/b5d18/1-1.jpg)\n\n- 선언 (Declaration phase) : 변수를 실행 컨텍스트에 등록하는 단계. 이 변수 객체는 스코프가 참조하는 대상이 됩니다.\n\n- 초기화 (Initialization phase) : 실행 컨텍스트에 존재 하는 변수에 메모리를 만드는 단계. 이 단계에서 할당된 메모리에는 `undefined`로 초기화 됩니다.\n\n- 할당 (Assignment phase) : 사용자가 `undefined`로 초기화된 메모리의 다른 값을 할당하는 단계.\n\nvar와 let/const는 이 3단계 순서에 차이가 존재한다.  \n**var 키워드는 선언과 초기화가 한 번에 이루어지지만 let은 선언 후 일시적 사각지대에 빠지게 된다. 선언과 초기화가 분리되어 진행된다는 의미이다.**\n\n# var 키워드의 라이프사이클\n\n![](https://dmitripavlutin.com/static/112c5cd0c5bdd2897944d81c384a648f/32366/2.webp)\n\n```js\nconsole.log(a) //undefined\n\nvar a = \"hi\"\n\nconsole.log(a) //hi\n```\n\n**var로 선언한 변수는 변수 선언전에 선언 단계와 초기화 단계를 동시에 진행한다.**  \n그래서 javascript는 실행 컨텍스트 변수 객체의 변수를 등록하고 메모리를 undefined로 만든다.  \n그렇기 때문에 변수 선언 전에 호출을 해도 undefined로 호출이 되는 호이스팅이 발생한다.\n\n# let 키워드의 라이프사이클\n\n![](https://dmitripavlutin.com/static/c707482b5c9368354684f45575d739d9/32366/4.webp)\n\n```js\nconsole.log(b) //Reference Error: b is not defined\n\nlet b = \"hi\"\n\nconsole.log(b)\n```\n\nlet으로 선언한 변수를 이전에 사용하려고 하면 Reference Error가 발생한다. 이를 보면 호이스팅이 발생하지 않는다고 보일 수 있다.\n\n하지만, 호이스팅이 일어나 메모리 공간을 확보한 뒤, 일시적 사각지대(TDZ) 에 빠져있는 상태이기 때문에 Reference Error가 발생하는 것이다.\n"},{"excerpt":"제어 컴포넌트 (Controlled Component) 컴포넌트의 상태나 속성(props)으로 주어진 값을 활용하는 컴포넌트. 사용자의 입력을 받는 컴포넌트에 event 객체를 이용해 로 값을 저장하는 방식이 제어 컴포넌트 방식이다. React에 의해 값이 제어되므로 제어 컴포넌트라고 부른다. 제어 컴포넌트는 사용자가 입력한 값과 저장되는 값이 실시간으로…","fields":{"slug":"/contents/posts/2021-08-22/"},"frontmatter":{"date":"August 22, 2021","title":"제어 컴포넌트와 비제어 컴포넌트"},"rawMarkdownBody":"\n# 제어 컴포넌트 (Controlled Component)\n\n컴포넌트의 상태나 속성(props)으로 주어진 값을 활용하는 컴포넌트.  \n사용자의 입력을 받는 컴포넌트에 event 객체를 이용해 `setState()`로 값을 저장하는 방식이 제어 컴포넌트 방식이다.  \nReact에 의해 값이 제어되므로 제어 컴포넌트라고 부른다.  \n제어 컴포넌트는 사용자가 입력한 값과 저장되는 값이 실시간으로 동기화된다.\n\n```jsx\nimport { useState } from \"react\"\n\nfunction App() {\n  const [inputValue, setInputValue] = useState(\"\")\n\n  return (\n    <div className=\"App\">\n      <input\n        onChange={(e) => setInputValue(e.target.value)}\n        value={inputValue}\n      />\n      <div>입력값 : {inputValue}</div>\n    </div>\n  )\n}\n\nexport default App\n```\n\n![](https://images.velog.io/images/nsunny0908/post/966f28ac-8f7b-4164-878a-3a90539cc7ca/Aug-23-2021%2023-46-03.gif)\n\n# 비제어 컴포넌트\n\nDOM 자체에서 폼 데이터가 다루어진다.\nHTML의 태그 중에서는 태그 자체적으로 상태를 갖는 경우가 있다.\n\n대표적인 경우가 바로 위에서 예시로 든 `<input>` 태그로, input 태그에 값을 입력하면 해당 값은 입력 폼 내부의 상태로 관리된다.\n\n```jsx\nimport { useRef } from \"react\"\n\nfunction App() {\n  const inputRef = useRef()\n\n  return (\n    <div className=\"App\">\n      <input type=\"text\" ref={inputRef} defaultValue=\"hi\" />\n      <div>입력값 : {inputRef.current?.value}</div>\n    </div>\n  )\n}\n\nexport default App\n```\n\n![](https://images.velog.io/images/nsunny0908/post/46f65729-a9c4-4f65-9f07-59eb9266c047/Aug-23-2021%2023-44-39.gif)\n"},{"excerpt":"Portals Portals는 리액트에서 컴포넌트를 렌더링할 때, 부모 컴포넌트의 바깥에 렌더링 할 수 있게 해주는 기능이다.\n일반적으로 포탈이 \"어딘가로 향하는 문\"이라는 개념으로 사용되는 것을 알면 이 기능에 대해 이해하기가 쉽다. 리액트에서는 컴포넌트를 렌더링할 때, children은 부모컴포넌트의 DOM 내부에 렌더링된다. 그러나 Portals를 …","fields":{"slug":"/contents/posts/2021-08-21/"},"frontmatter":{"date":"August 21, 2021","title":"React Portal"},"rawMarkdownBody":"\n![](https://i1.theportalwiki.net/img/thumb/b/b8/PortalBoxart.jpg/250px-PortalBoxart.jpg)\n\n# Portals\n\nPortals는 리액트에서 컴포넌트를 렌더링할 때, 부모 컴포넌트의 바깥에 렌더링 할 수 있게 해주는 기능이다.\n일반적으로 포탈이 \"어딘가로 향하는 문\"이라는 개념으로 사용되는 것을 알면 이 기능에 대해 이해하기가 쉽다.\n\n리액트에서는 컴포넌트를 렌더링할 때, children은 부모컴포넌트의 DOM 내부에 렌더링된다.  \n그러나 Portals를 사용하면 DOM 계층 구조 바깥에 있는 DOM 노드로 자식을 렌더링할 수 있다.\n\n```jsx\nReactDOM.createPortal(element, 배치할 DOM 식별자);\n```\n\n두번째 인자로 받는 Dom에 첫번째 인자로 받은 컴포넌트를 렌더링한다는 의미이다.\n\n간단한 예제로 사용법을 살펴보자.\n\n# 사용해보기\n\nreact를 사용해본 사람이라면 많이 보았을 index.html의 내부이다.  \n여기에 `portals`라는 id를 가진 div태그 하나를 추가한다.  \n이 portals라는 id를 가진 div 태그는 포탈의 종착지가 되며 div태그 안에 element를 렌더링한다는 의미다.\n\n```html\n<html lang=\"ko\">\n  <head> </head>\n  <body>\n    <div id=\"root\"></div>\n    <div id=\"portals\"></div>\n  </body>\n</html>\n```\n\n`App.js`의 내부 코드.  \nPortal이라는 컴포넌트를 만들어서 id로 DOM에 접근한 뒤 포탈로 children을 이동시킨다.\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nconst Portal = ({ children }) => {\n  const portals = document.getElementById('portals');\n  return ReactDOM.createPortal(children, portals);\n};\n\nexport default function App() {\n  return (\n    <div>\n      <Portal>portals 로 이동됨!</Portal>\n    </div>\n  );\n}\n```\n\n이 코드는 다음과 같은 과정을 거친다.\n\n1. `<Portal />` 컴포넌트가 감싸고 있는 요소는 `<Portal />`의 children이 되고\n2. id가 `portals`인 element의 DOM에 접근해 렌더링이 된다.\n\n그러나 여기서 의문점이 생긴다.  \nindex.html 의 root 가 아닌 다른 곳에 렌더링이 되는데 state를 사용할 수 있을까? 🤔\n\n# Portal을 통한 이벤트 버블링\n\n앞서 했던 질문에 대한 답변을 하자면, **결론적으로 portal인지 아닌지에 상관없이 다른 React의 자식요소와 같게 동작한다.** DOM 트리에서의 위치에 상관없이 portal은 여전히 React 트리에 존재하기 때문이다.\n\n코드를 다음처럼 바꿔보면 훨씬 이해하기 쉽다.\n\n```jsx\nimport React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\n\nconst Portal = ({ children }) => {\n  const portals = document.getElementById('portals');\n  return ReactDOM.createPortal(children, portals);\n};\n\nexport default function App() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <div>{count}</div>\n      <Portal>\n        <button onClick={() => setCount(count + 1)}>add</button>\n      </Portal>\n    </div>\n  );\n}\n```\n\n버튼을 누르면 count가 올라가고, count를 화면에 출력하는 간단한 코드이다.\n\n![](https://images.velog.io/images/nsunny0908/post/cbfe9215-a0bd-40cc-a229-1489f7dd0b17/Aug-22-2021%2001-12-44.gif)\n\nPortal과 count를 출력하는 div는 다른 위치에 있는데도 잘 동작하는 것을 볼 수 있다.\n이런식으로 portals을 활용해서 DOM 계층 구조 바깥에 있는 DOM 노드로 자식을 렌더링하는것이 가능하다.  \n컴포넌트 렌더링을 원하는 DOM에 자유롭게 할 수 있고 root에 적용되어있는 기본 css를 무시하고 컴포넌트를 만들고 싶을때 꽤 유용할 것 같다.\n​\n"},{"excerpt":"의미는 알고 있었으나 사용해볼 일이 없었던 context api. 이 글은 회사 소스 코드를 보다 자유자재로 context api가 사용되는 것을 보고 정리를 해야할 필요성을 느껴서 작성하는 글이다. Context Api 언제 사용할까? 기본적으로 react에서는 컴포넌트끼리 데이터를 주고받을때 로 데이터를 전달한다. 그러나 는 반드시 자신의 부모 컴포넌…","fields":{"slug":"/contents/posts/2021-08-16/"},"frontmatter":{"date":"August 16, 2021","title":"React Context Api"},"rawMarkdownBody":"\n> 의미는 알고 있었으나 사용해볼 일이 없었던 context api. 이 글은 회사 소스 코드를 보다 자유자재로 context api가 사용되는 것을 보고 정리를 해야할 필요성을 느껴서 작성하는 글이다.\n\n# Context Api 언제 사용할까?\n\n기본적으로 react에서는 컴포넌트끼리 데이터를 주고받을때 `props`로 데이터를 전달한다. 그러나 `props`는 반드시 자신의 부모 컴포넌트로부터 전달받아야한다는 명확한 한계가 있다.\n\n부모로 부터 `props`를 전달받는 과정이 depth가 하나라면 괜찮지만, 상위 컴포넌트로부터 데이터를 내려받는 depth가 깊어진다고 가정해보자.\n\n![](https://media.vlpt.us/images/nsunny0908/post/395df89c-379b-4c9d-bd85-586b6cd76480/%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8_%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%82%E1%85%B3%E1%86%AB_%E1%84%8B%E1%85%A1%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3.png)\n\n`A -> B -> C -> D`\n\n로 props를 전달하는 구조에서는 D에서 사용하기 위해 B, C 컴포넌트에서 사용하지 않는 props를 전달해줘야한다는 문제점이 있다.\n\n프로젝트 규모가 커지고 컴포넌트들이 많아질 수록 문제는 커진다. 이러한 문제점을 해결하기 위해 context api를 사용할 수 있다.\n\n# 어떻게 사용할까?\n\n프로젝트 어딘가에 context라는 상자 하나를 만든다고 생각하자.  \n그 상자 안에는 다른 컴포넌트에 전달하고 싶은 값을 넣어둔다.  \n이 값이 필요한 컴포넌트에 context 상자를 연결하면 그 순간부터 해당 컴포넌트 하위에 있는 컴포넌트들은 context 상자 데이터에 접근할 권한을 얻게 되는 것이다.\n\n![](https://media.vlpt.us/images/nsunny0908/post/33b1b48c-b6f6-464e-b525-3f9a33682711/%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8_%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%82%E1%85%B3%E1%86%AB_%E1%84%8B%E1%85%A1%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%202.png)\n\n그래서 리액트의 최상위 컴포넌트인 App에서 context와 연결한다면 프로젝트 내의 모든 컴포넌트에서 context 내부의 데이터에 접근할 수 있게 되는 것이다.\n\n간단한 코드와 함께 보면 이해가 쉽다.\n`createContext`를 통해 과일의 이름과 가격을 담는 context를 만든다.\n\n`store/fruits.js`\n\n```jsx\nimport React, { createContext } from \"react\"\nexport const FruitsContext = createContext()\n\nconst FruitsStore = (props) => {\n  const fruits = {\n    name: \"orange\",\n    price: 1000,\n  }\n\n  return (\n    <FruitsContext.Provider value={fruits}>\n      {props.children}\n    </FruitsContext.Provider>\n  )\n}\n\nexport default FruitsStore\n```\n\n최상위 컴포넌트인 App에서 사용하고자 하는 FruitsStore로 감싸주면 이제 하위의 컴포넌트에서 FruitsStore 내부의 fruits 데이터에 접근할 수 있는 것이다.\n\n`App.js`\n\n```jsx\n<FruitsStore>\n  <Router>\n    <Switch>\n      <Route exact path=\"/\" component={Name} />\n      <Route exact path=\"/price\" component={Price} />\n    </Switch>\n  </Router>\n</FruitsStore>\n```\n\n`Name.js`\n\n```jsx\nimport React, { useContext } from \"react\"\nimport { FruitsContext } from \"../store/fruits\"\n\nconst Name = () => {\n  const context = useContext(FruitsContext)\n  console.log(context)\n\n  return (\n    <div>\n      <span>{context.name}</span>\n    </div>\n  )\n}\n\nexport default Name\n```\n\n만약, FruitsStore가 Name컴포넌트만 감싸게 된다면 어떻게 될까?\n\n`Price.js`\n\n```jsx\nimport React, { useContext } from \"react\"\nimport { FruitsContext } from \"../store/fruits\"\n\nconst Price = () => {\n  const context = useContext(FruitsContext)\n  console.log(context) //undefined\n\n  return (\n    <div>\n      <span>{context.price}</span>\n    </div>\n  )\n}\n\nexport default Price\n```\n\n`undefined`가 된다.\nProvider로 감싸져 있는 하위 컴포넌트 들에서만 값에 접근이 가능하다.\n"},{"excerpt":"오늘 동료 중 한 분이 제목과 같은 질문을 내게 던졌다. 난 잠시동안 고민하다가 \"음.. 같지 않나요?\" 라고 대답했다. 동료는 말 없이 React 공식문서를 켜서 내게 보여주었다.  함수형 컴포넌트에 대한 검색결과가 없다. 영어로 쳐도 마찬가지다. 는 react 공식문서 그 어디에도 적혀져 있지 않다. 그렇다면 왜 나를 포함한 몇몇은 함수 컴포넌트를 함…","fields":{"slug":"/contents/posts/2021-08-12/"},"frontmatter":{"date":"August 12, 2021","title":"\"함수 컴포넌트\"와 \"함수형 컴포넌트\"가 같은 말이라고 생각하시나요?"},"rawMarkdownBody":"\n> 오늘 동료 중 한 분이 제목과 같은 질문을 내게 던졌다.  \n> 난 잠시동안 고민하다가 \"음.. 같지 않나요?\" 라고 대답했다.  \n> 동료는 말 없이 React 공식문서를 켜서 내게 보여주었다.\n\n![](https://media.vlpt.us/images/nsunny0908/post/0a1fa4ba-db0c-4920-8d93-ba200d85df85/Aug-13-2021%2000-58-22.gif)\n\n함수형 컴포넌트에 대한 검색결과가 없다.  \n영어로 쳐도 마찬가지다.  \n`Functional Component`는 react 공식문서 그 어디에도 적혀져 있지 않다.\n\n그렇다면 왜 나를 포함한 몇몇은 함수 컴포넌트를 함수형 컴포넌트로 오용해서 사용하고 있었을까?\n\n해당 이슈(https://github.com/reactjs/reactjs.org/pull/863) 를 보면 답을 얻을 수 있다.\n\n실제로 React에서는 Functional Component 라고 네이밍을 했다가, 누군가가 **\"함수형 컴포넌트를 사용하면 함수형 프로그래밍 방법으로 개발을 하는건가?\" 라는 혼란을 야기할 수 있다는 문제를 제기한 것이다.**\n\n그렇게 Functional Component라는 네이밍은 1년 가량 유지되다가 `Function Component`로 이름이 바뀌게 되었다.\n\n이런 흐름으로 인해 인터넷 상에서 많은 이들이 \"함수형 컴포넌트를 사용하면 함수형 프로그래밍을 할 수 있게 해준다.\" 와 같은 오해를 하게 된 것이다.\n\n# 함수 컴포넌트와 함수형 프로그래밍\n\n우선 함수형 프로그래밍에 대해 이해할 필요가 있다.\n함수형 프로그래밍은 순수함수의 구성으로 이루어진 프로그래밍 방법론이다.\n\n그렇다면 순수함수란 무엇일까.\n순수함수란\n\n> 1. `side effect`를 받지 않으며\n> 2. 같은 값을 넣었을때 리턴되는 값이 항상 같아야한다.\n\n간단하게 예를 들어서 살펴보자.\n\n```js\nconst plus = (a, b) => {\n  return a + b;\n};\n```\n\na와 b의 값을 받아 더한 값을 리턴해주는 함수가 있다.\n이 함수는 같은 값을 넣으면 항상 같은 값을 리턴해주기 때문에 순수함수이다.\n\n```js\nconst c = 1;\nconst plus = (a, b) => {\n  return a + b + c;\n};\n```\n\n그렇다면 이 함수는 어떨까?  \nplus함수 바깥에 있는 c의 값이 달라지면, 같은 a와 b의 값을 넣는다고 해도 다른 값이 리턴될 가능성이 있다.  \n이것은 순수함수가 아니다.\n\n그럼 다시 react로 돌아와서 우리가 작성하는 함수 컴포넌트는 어떤지 생각해보자.  \n같은 값을 넣으면 항상 같은 값이 리턴될까?\n\n예를 들어 반응형 페이지를 제작한다고 하면, 같은 컴포넌트를 사용한다고 하더라도 웹의 환경에 따라 결과물은 달라지기 때문에 순수함수라고 보기 어렵다.\n\n게다가 우리가 밥먹듯 사용하는 `useEffect`라는 hooks를 생각해보자. 이름부터가 effect이다. 우리는 컴포넌트를 작성할 때 side Effect를 필수 불가결하게 사용하고 있다.\n\n그러므로 함수 컴포넌트로 함수형 프로그래밍의 방법론으로 코드를 작성한다는 것은 nonsense한 면이 있다.\n\n# 마무리\n\n급 마무리를 짓자면, '함수형 컴포넌트'는 마치 \"함수형 컴포넌트를 사용하면 함수형 프로그래밍을 할 수 있게 해준다.\"와 같은 오해를 불러일으킬 수 있으니, 되도록이면 함수 컴포넌트 (Function Component) 라는 네이밍을 사용하자는 것이 결론이다.\n"},{"excerpt":"개발을 하다보면,  또는 가 아닌 경우를 판별해야하는 경우가 굉장히 많다.\n그럴때 유용하게 쓸 수 있는  병합 연산자에 대해 알아보자! null 병합 연산자 (??) 왼쪽 피연산자가  또는 일 때는 오른쪽 피연산자를 리턴하고,그렇지 않으면 (즉, 확정된 값이 있다면) 왼쪽 피연산자를 리턴하는 논리 연산자 예를 들어, a가  혹은 가 아닌 경우에는 a를 리…","fields":{"slug":"/contents/posts/2021-08-11/"},"frontmatter":{"date":"August 11, 2021","title":"null 병합 연산자(nullish coalescing operator)"},"rawMarkdownBody":"\n> 개발을 하다보면, `null` 또는 `undefined`가 아닌 경우를 판별해야하는 경우가 굉장히 많다.\n> 그럴때 유용하게 쓸 수 있는 `null` 병합 연산자에 대해 알아보자!\n\n# null 병합 연산자 (??)\n\n> 왼쪽 피연산자가 `null` 또는 `undefined`일 때는 오른쪽 피연산자를 리턴하고,그렇지 않으면 (즉, 확정된 값이 있다면) 왼쪽 피연산자를 리턴하는 논리 연산자\n\n예를 들어, a가 `null` 혹은 `undefined`가 아닌 경우에는 a를 리턴하고, 그 외의 경우에는 b를 리턴하는 코드를 작성한다고 가정해보자.\n\n```js\na !== null && a !== undefined ? a : b\n```\n\n이런식으로 작성할 수 있을 것이다.\n동일한 작동을 하는 코드를 null 병합 연산자를 사용해 작성하면 이렇게 작성하면 된다.\n\n```js\na ?? b\n```\n\n- a가 `null` 혹은 `undefined`가 아닌 경우 : a 리턴\n- 그 외의 경우 : b 리턴\n\n좀 더 구체적인 예와 함께 살펴보자.\n\n```js\nconst foo = null ?? \"value\"\nconsole.log(foo) // value\n\nconst foo = undefined ?? \"value\"\nconsole.log(foo) // value\n\nconst foo = 0 ?? \"value\"\nconsole.log(foo) // 0\n```\n\n그렇다면 비슷한 동작을 하는 `||` 연산자와는 어떻게 다른 것일까?\n\n# or 연산자 (||)와의 차이\n\nnull 병합 연산자는 or 연산자 `||`와 비슷하지만 차이가 있다.\n\n`||`는 첫 번째 `truthy` 값을 리턴한다.\n`??`는 첫 번째 `정의된(defined)` 값을 리턴한다.\n\n`null`과 `undefined`, 숫자 `0`을 구별해서 다뤄야할때 사용된다.\n예를 들자면,\n\n```js\nconst a = 0\nconst b = \"value\"\n\nconsole.log(a ?? b) // 0\n\nconsole.log(a || b) // 'value'\n```\n\n변수 a가 `0`인 경우, `??`를 사용하면 a의 값인 0이 리턴되지만 `||`를 사용하면 b의 값인 'value'가 리턴된다.\n\n# Optional chaining 연산자(?.)와의 관계\n\nnull 병합 연산자는 명확한 값으로 `undefined`과 `null`을 처리하고, optional chaining 연산자는 `null` or `undefined`일 수 있는 객체의 속성에 접근할 때 사용한다.\n\n```js\nlet foo = { sayHi: \"hi\" }\n\nconsole.log(foo.sayHi?.toUpperCase()) // \"HI\"\nconsole.log(foo.sayBye?.toUpperCase()) // undefined\nconsole.log(foo.sayBye.toUpperCase()) // TypeError\n```\n"},{"excerpt":"자바스크립트를 공부하면서 가장 진입장벽이 높은 개념인 프로토타입,, 🤪\n하나하나 차근차근 살펴보기! Prototype이란 자바스크립트는 프로토타입 기반 언어이다. 클래스 기반 언어에서는 상속을 사용하지만 프로토타입 기반 언어에서는 어떤 객체를 원형으로 삼고 이를 복제함으로써 상속과 비슷한 효과를 얻는다. Prototype은 말 그대로 객체의 원형이라고 할…","fields":{"slug":"/contents/posts/2021-07-04/"},"frontmatter":{"date":"July 04, 2021","title":"Prototype"},"rawMarkdownBody":"\n> 자바스크립트를 공부하면서 가장 진입장벽이 높은 개념인 프로토타입,, 🤪\n> 하나하나 차근차근 살펴보기!\n\n# Prototype이란\n\n자바스크립트는 프로토타입 기반 언어이다.  \n클래스 기반 언어에서는 상속을 사용하지만 프로토타입 기반 언어에서는 어떤 객체를 원형으로 삼고 이를 복제함으로써 상속과 비슷한 효과를 얻는다.\n\nPrototype은 말 그대로 객체의 원형이라고 할 수 있다. prototype이라는 프로퍼티는 그 용도가 약속되어 있는 특수한 프로퍼티다. prototype에 저장된 속성들은 생성자를 통해서 객체가 만들어질 때 그 객체에 연결된다.\n\n어떤 생성자 함수를 new 연산자와 함께 호출하면 constructor에 정의된 내용을 바탕으로 새로운 인스턴스가 생성된다. 이때 인스턴스에는 **proto**라는 프로퍼티가 자동으로 부여되는데 이 프로퍼티는 constructor의 prototype이라는 프로퍼티를 참조한다.\n\n예를 들어서 살펴보자!\n\nDog라는 함수를 만들고, Dog에 bark라는 prototype 속성을 추가해주었다.\n\n```js\nfunction Dog() {}\nDog.prototype.bark = \"bow wow\"\n```\n\n`new` 연산자를 통해 인스턴스를 생성했다.\n\n```js\nconst bori = new Dog()\n```\n\nbori를 호출해보면, `__proto__`라는 프로퍼티와 bark속성이 부여되어있다.\n\n![](https://media.vlpt.us/images/nsunny0908/post/d21a2d3d-f35e-4933-ad85-ee36621db7fd/A5AB7DB0-2E45-4EE3-BB4C-E3900CCFFE96.png)\n\n# Prototype Chain\n\n```js\nfunction Animal() {}\nAnimal.prototype.bark = true\n\nfunction Dog() {}\nDog.prototype = new Animal()\n\nfunction SmallDog() {}\nSmallDog.prototype = new Dog()\n\nconst bori = new SmallDog()\nconsole.log(bori.bark) //true\n```\n\n생성자 SmallDog을 통해 만들어진 객체 bori가 Animal의 프로퍼티 bark에 접근 가능한 것은 prototype 체인으로 SmallDog과 Animal이 연결되어 있기 때문이다. 내부적으로는 아래와 같은 일이 일어난다.\n\n> 1. 객체 bori에서 bark를 찾는다.\n> 2. 없다면 SmallDog.prototype.bark를 찾는다.\n> 3. 없다면 Dog.prototype.bark를 찾는다.\n> 4. 없다면 Animal.prototype.bark를 찾는다.\n\n만약, bori와 SmallDog의 bark속성을 변경하면 어떻게 될까?\n\n```js\nfunction Animal() {}\nAnimal.prototype.bark = true\n\nfunction Dog() {}\nDog.prototype = new Animal()\n\nfunction SmallDog() {}\nSmallDog.prototype = new Dog()\nSmallDog.prototype.bark = \"wal wal\"\n\nconst bori = new SmallDog()\nbori.bark = \"bow wow\"\nconsole.log(bori.bark) //bowwow\n```\n\n![](https://media.vlpt.us/images/nsunny0908/post/57ecf57d-4943-4c97-a535-446d03849da6/7BD9CB36-C869-40E2-8E15-5D2E00DB3505.png)\n\n> prototype는 객체와 객체를 연결하는 체인의 역할을 한다.\n> 이러한 관계를 **prototype chain**이라고 한다.\n\n만약!! SmallDog.prototype = Animal.prototype 으로 한 후,\nSmallDog의 bark 값을 변경하면 어떻게 될까?\n\n```js\nfunction Animal() {}\nAnimal.prototype.bark = true\n\nfunction Dog() {}\nDog.prototype = Animal.prototype\n\nfunction SmallDog() {}\nSmallDog.prototype = Animal.prototype\nSmallDog.prototype.bark = \"bow wooooow\"\n\nconst bori = new SmallDog()\n```\n\n> SmallDog.prototype = Animal.prototype 으로 하면 안된다.\n> SmallDog.prototype의 값을 변경하면 Animal.prototype도 변경하기 때문이다.\n\n![](https://media.vlpt.us/images/nsunny0908/post/c018f4c6-3057-4d60-90ca-1b8aa198a6aa/11FDD7A9-BF9B-442F-82AA-0A9350A17411.png)\n\nDog.prototype = new Animal()은 Animal.prototype의 원형으로 하는 객체가 생성되기 때문에 new Animal()를 통해서 만들어진 객체에 변화가 생겨도 Animal.prototype의 객체에는 영향을 주지 않는다.\n\n# Prototype과 Class의 차이\n\nes6부터 Class 문법이 추가되었다.  \n그렇다고 자바스크립트가 프로토타입 기반 언어에서 클래스 기반 언어가 된 것은 아니다.\n그렇다면 Class와 Prototype은 어떤 차이가 있을까?\n\n## Class는 상속이 가능하지만 Prototype은 상속이 불가능하다.\n\nPrototype에서 상속을 구현하고자 한다면 앞서 설명했던 prototype chaining을 사용해야한다. 그렇지만 Class를 사용하면 객체 생성자로 구현했던 코드를 조금 더 명확하게 구현 할 수 있고 상속도 훨씬 쉽게 해줄 수 있기 때문에 Class를 사용하면 굳이\nprototype chaining 을 써야할 필요가 없다.\n\n## 불변성과 가변성\n\nClass는 '틀' 과 같아서 도중에 바뀌는 일이 없다. 같은 틀 안에서 찍어낸 인스턴스를 프로퍼티나 메소드를 추가 하지 않는 이상 동일한 형태를 가진다.\n\n반면 prototype 기반 언어는 객체가 곧 설계도가 되기 때문에 동적인 설계가 가능하다.\n"},{"excerpt":"코딩 부트캠프가 내게 준 것 국비 학원의 '풀스택(사실상 백엔드에 치중된)' 커리큘럼을 마친 후, 백엔드 개발자로 한 회사에서 인턴을 거친 나는 프론트앤드로서 포지션을 확정짓고 이후 3개월 기간의 코딩 부트캠프에 등록하게 된다.  이전 글에서 3개월이라는 기간에 내가 가진 최대한의 것을 쏟아보겠다 했는데, 실제로 이 3개월이라는 기간동안 나는 내가 이렇게…","fields":{"slug":"/contents/posts/2021-06-13/"},"frontmatter":{"date":"June 13, 2021","title":"코딩 부트캠프와 좋은 개발자"},"rawMarkdownBody":"\n# 코딩 부트캠프가 내게 준 것\n\n국비 학원의 '풀스택(사실상 백엔드에 치중된)' 커리큘럼을 마친 후, 백엔드 개발자로 한 회사에서 인턴을 거친 나는 프론트앤드로서 포지션을 확정짓고 이후 3개월 기간의 코딩 부트캠프에 등록하게 된다.\n\n![](https://media.vlpt.us/images/nsunny0908/post/608b4a48-ba69-4adc-bf2e-6813ed29478b/IMG_5910.JPG)\n\n이전 글에서 3개월이라는 기간에 내가 가진 최대한의 것을 쏟아보겠다 했는데, 실제로 이 3개월이라는 기간동안 나는 내가 이렇게까지 열정을 가지고 무언가에 몰입했던 적이 있었나싶을 정도로 코딩에 몰두했다.  \n새로운 기술스택을 배울 때나 기업협업 같은 완전히 낯선 환경에 무방비로 던져졌을 때 느꼈던 기분은 정말이지, 눈물이 찔끔 날 정도로 힘이 들었다.  \n그렇지만 '엉덩이가 무거운 사람이 승리한다'는 모토를 가슴에 깊게 새기고 왕복 3시간이나 걸리는 거리에 살았음에도 불구하고 정식 일정이 시작되는 10시보다 최소 30분, 최대 1시간씩은 늘 먼저 도착해서 홀로 코딩을 했다.  \n그 만큼 나는 코딩을 잘 하고 싶었고, 또 잘 해낼 수 있으리라는 믿음을 지니고 있었다.\n\n---\n\n![](https://media.vlpt.us/images/nsunny0908/post/dae5e001-0aa4-4835-9455-66472a4f42b6/89919D9D-78BA-4648-9987-810BEBC96454.png)\n\n아침에 먹는 위워크 선릉점의 카푸치노는 꿀맛 ☕️\n\n---\n\n# 개발자의 숙명\n\n나는 코딩이 재밌다. 코딩 하느라 시간가는 줄 모르는 때가 많다.  \n하지만 어떤 일을 직업으로 삼을 때는 단순히 '재미'를 기준으로 삼아서는 안 된다는 것을 잘 알고 있다. 재미를 뛰어넘는 무언가가 있어야 업으로 삼아 오래도록 해나갈 수 있기 때문이다.  \n씁쓸하지만 어쩔 수 없는 진실, **'재미'는 결국 없어지기 마련이므로.**\n\n선배 개발자들은 이러한 딜레마를 어떻게 이겨냈을까, 하는 고민과 질문을 거듭하다 나름의 답을 내려보았다.\n\n> 바로 평생 공부해야하는 직업이라는 것.\n\n빠르게 변화하는 IT업계 중심에 서 있는 직업으로서 이것은 어쩔 수 없는 개발자의 숙명이다.  \n평생 공부해야한다는 것이 누군가에게는 끔찍하게 들릴 수 있겠으나, 도태되고 그 상황에 고여버리는 것이 더 무섭다는 것을 이미 경험한 나로서는 이렇게 숙명적으로라도 공부하고 앞으로 나아가야 하는 개발자라는 직업이 굉장히 매력적으로 느껴졌으며, 그렇기에 직업으로까지 선택할 수 있었다고 생각한다.\n\n선택 후에는 고민이 뒤따르기 마련이다.  \n개발자를 선택했으니 이제는 고민해야 할 차례이다.\n\n**\"그렇다면 어떤 개발자가 될 것인가\"에 대한 고민.**\n\n# 어떤 개발자가 될 것인가\n\n> 사용자 가치 중심의 개발을 하는 개발자\n\n이 말은 결국 좋은 서비스를 제공해야 한다는 말과도 직결 되는데, 좋은 서비스란 결국 사용자가 의도한 바를 잘 수행하고 기대한 결과를 정확하고 빠르게 전달하는 UI, UX를 지녀야한다고 생각한다.  \n훌륭한 UI, UX가 곧 훌륭한 서비스를 위한 충분조건은 아닐지 몰라도, 확실한 필요조건은 된다고 생각한다.  \n이러한 생각의 태도는 곧 모든 개발자가 '사용자 가치 중심'의 개발을 해야 하는 이유로도 설명이 되며, 나아가 프론트앤드 개발자의 존재 가치로도 대변이 되는데, 사용자의 경험과 가장 밀접하게 맞닿아 있는 포지션이 바로 프론트앤드이기 때문이다.\n\n> 맷집이 강한 개발자\n\n기업협업 인턴십 과정동안 나는 갑자기 둥지 밖으로 내던져진 아기새가 된 기분을 매 순간 느낄 수밖에 없었는데, 한 번도 다뤄본 적 없는 기술스택, 의도를 파악할 수 없는 코드들을 마주 할 때마다 너무나 당황스럽고 겁이 났기 때문이다.  \n이러한 상황과 관련해서 상담 코치이신 영은님과 상담을 하기도 했었다. 많은 격려와 다정한 조언이 있었는데, 그 중에서도 가장 내 마음에 크게 울림을 준 말이 있다.\n\n**\"잘 맞는 연습을 하세요.\"**\n\n개발자로 일을 하면, 어쩌면 일을 그만두는 그 순간까지 계속해서 새로운 기술스택을 맞닥뜨려야할 텐데, 4주간의 인턴 기간 동안 맷집을 키워오라는 의미였다.  \n영은님의 조언 이후로 나는 '그래. 고작 이 정도 가지고 힘들어하면 앞으로 진짜 실무를 할 때 어떻게 극복할 수 있겠어?'하며 계속해서 마인드셋을 하며 상황을 버텨냈다.  \n그리고 당시의 그러한 어려움에 대한 기억과 그로 인한 극복의 의지는 여전히 내 마음에 남아있다.  \n계속 맷집을 키워서 아무리 어려운, 처음 보는 기술스택에 맞더라도 '잘 맞는' 개발자가 되고싶다.\n\n> 꾸준한 개발자\n\n워렌버핏은 \"지식은 복리처럼 쌓인다\"고 했다.  \n개발을 처음 시작했을 당시에는 정말이지 뭐가 뭔지 하나도 알지 못 했다.  \n간단한 로직도 짜지 못 해서 매번 스택오버플로우를 전전했다.  \n사실 몇 개월 지난 지금도 당시 나를 힘들게 했던 문제들을 복기하면, 몇 개는 너무나 쉽게 느껴지는 반면, 몇 개는 여전히 확신이 서질 않는다.  \n나는 개발 공부를 시작한 이후로 매일은 아니더라도 시간이 나는대로 계속해서 학습한 내용을 정리하고, 어쩌면 또 마주할지도 모르는 에러에 대한 해결방법에 대해 아카이빙하는 습관을 들이고자 노력했다.  \n언젠가는 몰랐던 문제들에 대한 해답을 스스로 내릴 수 있기를 꿈꾸며, 꾸준히 개발을 이어 나가고자 하는 마음에서 원동력을 얻고 있다.\n\n> 같이 일하고 싶은 개발자\n\n개발자가 개발을 잘해야하는 것은 무척이나 당연한 일이다.  \n그래서 초반에는 개발을 잘 하는 것이 개발자가 지닌 최고의 덕목이라 생각했다.  \n하지만 팀프로젝트를 다섯 번 정도 거친 지금, 그 생각은 조금 달라졌다.\n\n**개발을 잘 하는 사람이 반드시 같이 일 하고 싶은 개발자는 아니라는 것.**\n\n결국 프로젝트를 대하는 태도가 좋은 사람이 곧 같이 일 하고 싶은 사람이라는 판단과 함께, 개발 역량은 시간이 지남에 따라 높아지고 좋아질 수 있지만, 태도는 쉽게 변하지 않는다는 것을 깨달았기 때문이다.  \n그리고 이러한 깨달음은 곧 내 스스로에게 질문을 던지게 만들었다.\n\n**\"과연 나는 같이 일하고 싶은 개발자인가?\"**\n\n앞으로 있을 수많은 프로젝트 속에서 내가 가장 촉을 세워 집중해야 할 질문이라고 생각한다.  \n끊임없이 스스로를 되돌아보는 태도를 통해 같이 일 하고 싶은 개발자가 되길 기대한다.\n\n![](https://media.vlpt.us/images/nsunny0908/post/344e95f5-da8a-410b-a630-eae6f6f4aae6/4C3B1D17-FE68-4AD7-88EF-61FABEBCC925.png)\n![](https://media.vlpt.us/images/nsunny0908/post/babd059f-4bb2-493d-8ee7-22060fef9068/IMG_6124.JPG)\n![](<https://images.velog.io/images/nsunny0908/post/97aa198e-e476-4706-af59-cb949c65549a/iOS%20%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%84%8C%E1%85%B5%20(8).jpeg>)\n"},{"excerpt":"(안면 인식, 3D 프린팅에 AI 기술을 합작한 딥러닝 알고리즘이 렘브란트의 그림을 모방해서 만든 <넥스트 렘브란트> 프로젝트) 기술? 예술? 사진 미학을 배우며 항상 남들에게, 그리고 스스로에게 던졌던 질문이 하나 있다. \"사진은 기술인가, 예술인가?\" 이 질문은 항상 사진학과 동기와 선후배들 사이에서 화두가 되는 질문이었는데, 고민 끝에 나는 이러한 …","fields":{"slug":"/contents/posts/2021-05-17/"},"frontmatter":{"date":"May 17, 2021","title":"기술을 할 것인가, 예술을 할 것인가"},"rawMarkdownBody":"\n![](https://media.vlpt.us/images/nsunny0908/post/2bcd9a06-9aec-4a7f-af2f-30895b1e7de7/image.png)\n\n(안면 인식, 3D 프린팅에 AI 기술을 합작한 딥러닝 알고리즘이 렘브란트의 그림을 모방해서 만든 <넥스트 렘브란트> 프로젝트)\n\n# 기술? 예술?\n\n사진 미학을 배우며 항상 남들에게, 그리고 스스로에게 던졌던 질문이 하나 있다.\n\n> \"사진은 기술인가, 예술인가?\"\n\n이 질문은 항상 사진학과 동기와 선후배들 사이에서 화두가 되는 질문이었는데, 고민 끝에 나는 이러한 대답을 내리기로 결정한다.\n\n> \"'기술(도구)'로 '예술(결과)'을 하는 것\"\n\n이러한 고민과 대답은 곧 현재 나의 포지션인 프론트앤드 업무와도 연결이 된다.  \n코드로 UI를 만들어냄을 통해 화면을 구상하는 것은 곧 예술의 영역인 동시에 과학기술의 영역이기 때문이다.\n\n사실 기술과 예술을 나누는 것이 큰 의미가 있는가, 하는 의문 역시도 나를 고민하게 만드는 일인데, 결국 '기술과 예술의 호환과 융합'을 통한 시너지가 곧 하나의 커다란 예술이자 기술이 된다고 생각하기 때문이다.\n\n# 기술자이자 예술가\n\n**`과학기술은 예술의 원천이 되고, 예술은 과학기술에 영감을 제공한다.`**\n\n나는 이 말을 둘의 미묘한 관계 속 시너지 작용을 통해 보다 발전된 무언가가 탄생한다는 말로 해석하고자 한다. 그리고 나는 내 스스로를 기술자이자 예술가로 정의내리고 싶다.  \n결국 개발자는 기술과 예술의 융합을 통한 새로운 창조를 가능하게 하는 존재인 것이다.\n\n오늘도 나는, 개발이라는 세계 안에서 기술로 예술을 하며, 또 예술로 기술을 하며 무한한 가능성을 통해 끊임없이 창조하는 사람이 되길 진심으로 희망한다.\n"},{"excerpt":"클론프로젝트를 하면서 꼭 한번 해보고 싶었던 무한 스크롤 기능과 로딩바 기능을 구현해보았다! 기존 scroll event의 문제점 스크롤을 끊임없이 감지하고 동기적으로 실행되기 때문에 메인 스레드에 영향을 준다.\n실제로 스크롤 이벤트로 무한스크롤기능을 구현할때의 상황. scroll이 맨 밑에 있을때 감지해주는 함수를 달아놨는데 스크롤이 계속 맨 밑에 머물…","fields":{"slug":"/contents/posts/2021-05-10/"},"frontmatter":{"date":"May 10, 2021","title":"Intersection Observer API를 활용한 무한스크롤"},"rawMarkdownBody":"\n![](https://media.vlpt.us/images/nsunny0908/post/4b613a08-f328-453e-b7f3-0e92bf8634ee/May-09-2021%2018-07-31.gif)\n\n> 클론프로젝트를 하면서 꼭 한번 해보고 싶었던 무한 스크롤 기능과 로딩바 기능을 구현해보았다!\n\n# 기존 scroll event의 문제점\n\n스크롤을 끊임없이 감지하고 동기적으로 실행되기 때문에 메인 스레드에 영향을 준다.\n실제로 스크롤 이벤트로 무한스크롤기능을 구현할때의 상황.  \nscroll이 맨 밑에 있을때 감지해주는 함수를 달아놨는데 스크롤이 계속 맨 밑에 머물러있을때 끊임없이 함수가 호출되고 있다.\n\n# Intersection Observer API\n\n간단히 말하자면 타겟이 화면에 노출되었는 지의 여부를 관찰할 수 있는 API\n교차되었을때 실행할 `callback` 함수와 `option`을 인자로 받는다.\n\n```js\nconst observer = new IntersectionObserver(callback, options)\n```\n\n## callback\n\n타겟 엘리먼트가 교차되었을 때 실행할 함수\n\n## options\n\nobserver 콜백이 호출되는 상황을 조작할 수 있다.\n\n- `root`  \n  교차 영역의 기준이 될 root 엘리먼트.  \n  기본값은 브라우저의 viewport\n- `rootMargin`  \n  root엘리먼트의 margin값  \n  threshold  \n  타겟에 대한 교차 영역 비율  \n  0의 경우 : 타겟 엘리먼트가 교차영역에 진입했을 시점에 observer를 실행  \n  1의 경우 : 타켓 엘리먼트 전체가 교차영역에 들어왔을 때 observer를 실행\n\n## method\n\n- IntersectionObserver.observe(target)\n  - 타겟 엘리먼트에 대한 IntersectionObserver를 등록 (관찰 시작)\n- IntersectionObserver.unobserve(target)\n  - 타겟 엘리먼트에 대한 관찰 중지\n- IntersectionObserver.disconnect()\n  - 모든 타겟 엘리먼트에 대한 관찰 중지\n\n# React hook에 적용해보기\n\n우선 `target`, 로딩중인지 아닌지를 판별해줄 `isLoading`, 현재 아이템 갯수를 나타내는 `itemCount`를 state로 지정해준다.\n\n```js\nconst [itemCount, setItemCount] = useState(1)\nconst [isLoading, setIsLoading] = useState(false)\nconst [target, setTarget] = useState(null)\n```\n\ntarget에 변화가 있을때마다 실행해줄 `useEffect`에 observer 객체를 선언한다.\n\n```js\nuseEffect(() => {\n  let observer\n  if (target) {\n    observer = new IntersectionObserver(callback, { threshold: 1 })\n    observer.observe(target)\n  }\n  return () => observer && observer.disconnect()\n}, [target])\n```\n\n`callback`함수의 인자로 entry와 observer를 받는다.  \n타겟의 교차 상태를 boolean값으로 반환하는 `entry.isIntersecting`가 `true`일때 list를 fetch하는 함수를 호출하고 `itemCount`에 1을 더해 setState해준다.  \n(난 한페이지당 1개의 리스트만 호출하고 스크롤이 끝에 다다랐을때 하나씩 더 보여주는 무한스크롤을 구현 예정이다.)\n\n```js\nconst callback = ([entry], observer) => {\n  if (entry.isIntersecting) {\n    fetchBidsLists()\n    setItemCount(itemCount + 1)\n    observer.observe(target)\n  }\n}\n```\n\n리스트를 fetch해오는 함수.\n우선 `isLoading`을 `true`로 setState해주고, fetch를 통해 백엔드로부터 데이터를 받아온다.  \nsetTimeout을 통해 약간의 시간차를 줘 로딩바가 더 잘보일 수 있도록 했다.  \nlist의 갯수가 현재 `itemCount`와 같으면 loading이 끝난것이기 때문에 다시 `false`로 바꿔주었고, list를 `itemCount`의 수만큼 slice해 setState해주었다.\n\n```js\nconst fetchBidsLists = () => {\n  setIsLoading(true)\n  setTimeout(() => {\n    fetch(`${BIDS_API}/${day}`)\n      .then((res) => res.json())\n      .then((bidsData) => {\n        setIsLoading(!(bidsData.auctions.length === itemCount))\n        setBidsLists(bidsData.auctions.slice(0, itemCount))\n      })\n    setIsLoading(false)\n  }, 400)\n}\n```\n\n마지막으로 컴포넌트가 언마운트될때 `isLoading`을 `false`로 setState해준다.\n\n```js\nuseEffect(() => {\n  return () => setIsLoading(false)\n}, [])\n```\n\n로딩바부분.\n`isLoading`이 `true`일때만 로딩바가 보여야하므로 조건부렌더링을 걸어주었고 setTarget을 `forwardRef`로 지정해주었다.\n`forwardRef`는 React 컴포넌트에 ref prop을 넘겨서 그 내부에 있는 HTML 엘리먼트에 접근을 하게 해준다.\n\n```jsx\n{\n  isLoading && <Loading forwardRef={setTarget} />\n}\n```\n"},{"excerpt":"재미 나는 개발과는 무관한 사진학과 출신이다. 졸업 전시를 위한 포트폴리오 제작 당시, 남들과는 다른 차별점을 두길 좋아하던 나는 지금껏 작업해온 모든 것을 올릴 수 있는 개인 홈페이지를 통해, '나만의 색깔을 마음껏 드러낼 수 있는 곳'을 운영하고 싶다는 생각을 했다. 어릴 때부터 늘 포토샵과 나모웹에디터를 만지작 거리며 자라온 터라 항상 나만의 공간을…","fields":{"slug":"/contents/posts/2020-12-24/"},"frontmatter":{"date":"December 24, 2020","title":"사진학도가 개발자가 된 이유"},"rawMarkdownBody":"\n# 재미\n\n나는 개발과는 무관한 사진학과 출신이다. 졸업 전시를 위한 포트폴리오 제작 당시, 남들과는 다른 차별점을 두길 좋아하던 나는 지금껏 작업해온 모든 것을 올릴 수 있는 개인 홈페이지를 통해, '나만의 색깔을 마음껏 드러낼 수 있는 곳'을 운영하고 싶다는 생각을 했다.  \n어릴 때부터 늘 포토샵과 나모웹에디터를 만지작 거리며 자라온 터라 항상 나만의 공간을 만들고 꾸미는 것에 관심이 있었는데, 포트폴리오를 계기로 삼아 실천에 옮기기로 결심을 한 것이다.  \n당시에는 아무런 전문지식이 없었기 때문에 비교적 쉬워 보이는 티스토리 블로그를 선택했고, 다른 사람들이 배포해준 다양한 스킨들을 내 취향대로 수정하며 재미를 붙이기 시작했다.\n\n---\n\n🏡 내가 만든 티스토리 스킨\n![](https://media.vlpt.us/images/nsunny0908/post/d2e3bfd0-b08b-4864-8908-f0f0bd1e9c6a/img1.daumcdn.gif)\n\n![](https://media.vlpt.us/images/nsunny0908/post/e004a033-828b-4458-9166-a838680e76e7/%E1%84%83%E1%85%A1%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A9%E1%84%83%E1%85%B3.gif)\n![](https://media.vlpt.us/images/nsunny0908/post/adf8c654-8a37-4db8-ad68-79ea55225727/mars-skin.gif)\n\n---\n\n특히나 HTML과 CSS수정하는 것에 굉장한 흥미를 느꼈는데, 수정을 통해 결과물이 즉각적으로 눈에 보이는 것에 짜릿함을 느끼기도 하고 또 성취감도 들었기 때문이다.  \n나중에는 수정에 그치지 않고 직접 스킨을 만드는 수준에까지 이르게 되었다.  \n정작 해야 하는 사진 보정을 뒤로 제쳐두고 블로그 스킨을 수정하고 만드는 일로 밤을 지새우는 날들이 늘어났다.\n넣고 싶은 효과나 기능을 검색하여 알지도 못하는 Javascript 소스를 복사, 붙여넣기를 반복하다 문득, `이건 대체 어떤 방식으로 적용이 되는 거지?` 하는 궁금증이 생기게 되었다.\n\n# 성장과 도태의 갈림길\n\nJavascript의 작용 원리와 같은 보다 근원적인 것에 대한 관심이 직업으로 이어지기까지는 사실 꽤나 오랜 시간이 걸렸다.  \n졸업후 바로 영상 편집 분야로 취업을 하게 되었고, 이어 약 4년에 걸쳐 두 군데의 관련 회사를 다녔기 때문이다.\n그렇게 회사 생활을 이어가던 어느 날, 문득 발전에 대한 어떠한 열정도 관심도 갖질 않는 나의 고여있는 모습을 발견하게 된다.  \n도태되는 것은 참을 수 없지만 그렇다고 영상 분야에서의 발전을 하기에는 너무나 벅차던 그 때, **'앞으로 뭘 하고 살아야지?'** 하는 고민을 밤낮으로 하며 심적으로도 체력적으로도 무척이나 힘든 시기를 보내게 된다.  \n그렇게 고민에 밤잠 설치던 어느 날, 마치 구원의 동앗줄처럼 유튜브 알고리즘은 개발과 관련된 영상을 내게 보여주었다. 접하면 접할수록 개발자라는 직업에 굉장한 매력을 느끼게 되었다.  \n특히나 'IT 업계는 너무나도 빠른 발전이 이루어지는 분야이기 때문에 끝없이 성장을 해야만 하는 운명'을 타고났다는 점에 마음을 송두리째 빼앗기게 된다.\n\n도태 되는 것에 두려움을 느끼던 나에게 '끝없이 성장이 가능한 직업'이란 마치 이 세상에 없던 무언가를 발견한 것만 같은 충격이었고, 마침내 '개발자'라는 직업을 업으로 삼는 것에 대한 진지한 고민을 본격적으로 시작하는 계기로 삼게 된다.\n\n# 왜 하필, 프론트앤드?\n\n6개월간의 국비교육과정에서 접한 '프론트 과정, 백엔드 과정' 중 내게 보다 매력적으로 다가온 것은 프론트앤드였는데, 그 이유는 다음과 같다.\n\n> 1. 사용자의 요구(UI, UX)와 맞닿아 있다!\n\n유저의 반응을 실시간으로 확인하고 이에 대한 피드백을 즉각적으로 할 수 있다는 부분이 가장 매력적이다.  \n취미로 블로그 스킨을 제작하던 당시, 주변사람들이 원하는 방향에 맞춰 티스토리 스킨을 만들어준 적이 꽤 있는데, 이 과정에서 1차 작업물에 대한 실제 사용자 기반의 피드백을 받은 적이 여러차례 있다.  \n직접 사용해본 사람들이 겪는 불편함에 대해 즉각적으로 수정을 함으로써 그 문제가 해소 되었을 때 오는 쾌감이 굉장했다.  \n물론 당시 내가 경험한 피드백은 실제 현장에서 겪을 피드백과는 수준이 비교가 되지 않겠지만, 그렇기 때문에 현장에서 벌어지는 문제에 대한 피드백이 이루어질 때 경험할 쾌감 역시도 엄청날 것이라는 예상과 기대를 하고 있다.\n그래서 두렵고, 걱정되지만 동시에 설레고 즐겁다! ✨\n\n> 2. 언어의 확장성과 유동성이 핵심인 JavaScript, 게다가 Node.js와 함께 하면 로컬 환경에서도 가동이 가능하다!\n\nJavascript를 배우면 배울수록 느끼는 것이 있다. 바로 확장성과 유동성이 굉장한 언어라는 것이다.  \n확장성과 유동성은 내가 매력을 크게 느끼는 지점이기도 한데, 반대로 이러한 javascript의 자유로운 성격을 '예측 불가능함'으로 해석하여 사악하다고 평가하는 사람들도 있다는 것을 고려하면, 자바스크립트가 유독 나와 잘 맞는 언어가 아닐까, 하는 생각을 자연스레 하게 된다.\n\n![](https://media.vlpt.us/images/nsunny0908/post/b792f523-8564-431b-98f6-642fa8493c51/meme.png)\n\n물론 '포지션은 언어 따라 결정하는 게 아니다'라는 우려의 말들도 있지만, 그 언어에 흥미가 없다면 포지션 자체에 대한 흥미 역시도 떨어지는 것은 자연스러운 현상이라고 생각한다.  \n엄격한 Java를 공부하다가 자유롭고 변화무쌍한 Javascript를 만나서 더 그렇게 느끼는 것일 수도 있지만, 어찌됐든 나에게 있어서 Javascript는 최고의 언어이다!\n\n# 앞으로\n\n![](https://media.vlpt.us/images/nsunny0908/post/8a7739ab-bb70-4ad8-9796-564255717532/IMG_3B233B3049AF-1.jpeg)\n\n우선, 3월에 있을 코딩 부트캠프에 올인 할 예정이다.  \n3개월이라는 기간동안 내가 비약적인 성장을 하고 대단한 개발자로 탈바꿈 할 것이라는 기대는 하지 않는다. 그렇기엔 너무나 짧은 시간이다.  \n하지만 성장과 발전에 있어서 제약을 두려 하지는 않는다.  \n물론 인간은 100%를 해낼 수 있는 존재가 아니고, 나 역시도 언제까지나 미완의 존재로 살아가겠지만, 그럼에도 불구하고 언젠가 이루어낼 완성을 꿈꾸며 살아가려 한다.  \n태도가 사람을 만든다는 말을 믿는다. 그래서 나는 완성을 꿈꾸는 태도로 앞으로 있을 3개월에 최대한의 것을 쏟아보고자 한다.  \n한 번 주어진 내 삶을 그래도 잘 살아내고 싶다.  \n열정을 쏟고 노력해서 성장하는 인간으로서의 삶을 살아내고 싶다.\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}