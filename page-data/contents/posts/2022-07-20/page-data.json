{"componentChunkName":"component---src-templates-post-jsx","path":"/contents/posts/2022-07-20/","result":{"data":{"site":{"siteMetadata":{"title":"kimnamsun"}},"markdownRemark":{"id":"df7ea411-5375-56e2-8ce9-4f86bb631af7","excerpt":"프론트앤드 스터디에서 진행한 OSI 7계층 중 2계층에 대한 발표자료 2계층 (데이터링크 계층, DataLink Layer) 네트워크 장비간의 신호를 주고받는 규칙을 정하는 계층 데이터를 전송할 때 발생하는 충돌을 막기 위해서 데이터를 송수신하는 순서나 규칙이 필요하게 되었다. 신호가 닿는 범위(세그먼트)에서의 데이터 전송에 관해서는 2계층에서 처리한다.…","html":"<blockquote>\n<p>프론트앤드 스터디에서 진행한 OSI 7계층 중 2계층에 대한 발표자료</p>\n</blockquote>\n<h1>2계층 (데이터링크 계층, DataLink Layer)</h1>\n<ul>\n<li>네트워크 장비간의 신호를 주고받는 <strong>규칙</strong>을 정하는 계층</li>\n<li>데이터를 전송할 때 발생하는 충돌을 막기 위해서 데이터를 송수신하는 순서나 규칙이 필요하게 되었다.</li>\n<li>신호가 닿는 범위(세그먼트)에서의 데이터 전송에 관해서는 2계층에서 처리한다.</li>\n</ul>\n<p>1계층 장비(허브, 리피터)로 여러 컴퓨터에 데이터를 전달하려면?</p>\n<p><img src=\"https://velog.velcdn.com/images/nsunny0908/post/25609c44-ee2e-45b8-80de-89818e097bb8/image.png\">\n허브 사용</p>\n<p><img src=\"https://velog.velcdn.com/images/nsunny0908/post/f4cdb6b6-0a75-4998-850f-249403367097/image.png\"></p>\n<ul>\n<li>\n<p>허브는 한 컴퓨터에서 전송된 데이터를 모든 컴퓨터에게 다 전송한다.<br>\n이를 <code class=\"language-text\">플러딩</code>이라고 한다.<br>\n→ MAC 주소를 알지 못하기 때문.<br>\n→ 비효율적, 데이터 충돌 위험성⬆️</p>\n<ul>\n<li>맥주소: NIC(랜카드)에 부여된 고유 식별 값.</li>\n</ul>\n</li>\n</ul>\n<p>2계층에서 사용하는 장비인 스위치 브릿지 등은 MAC주소를 알기 때문에 4번이 1번pc한테만 전송하는게 가능하다.</p>\n<p>이것처럼, 우리는 2계층의 프로토콜과 장비들로 이런 문제를 해결할 수 있다.</p>\n<h2>2계층의 장비들로 여러대의 컴퓨터를 연결하려면?</h2>\n<ul>\n<li>네 대의 컴퓨터가 스위치라는 장비를 통해 연결되어 있다.</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/nsunny0908/post/02a59af8-b85a-4294-8126-b394b60949b0/image.png\"></p>\n<ul>\n<li>나머지 세 대의 컴퓨터가 ‘예림'의 컴퓨터로 데이터를 동시에 보냈다고 가정했을때 ‘예림'이의 컴퓨터는 데이터를 0101111110001.. 형식으로 붙어서 받게 된다.</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/nsunny0908/post/8a9b8d55-5c02-4087-9cc3-8e1dbba2d7f5/image.png\"></p>\n<ul>\n<li>제대로 잘 끊어서 받지 않으면 엉뚱한 데이터를 받게 된다.</li>\n<li>제대로 잘 끊어서 데이터를 받기 위해 데이터를 보내는 쪽은 <strong>데이터의 앞, 뒤에 특정한 비트열</strong>을 붙인다.</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/nsunny0908/post/74ed3636-a1ae-494f-9d22-5de1f02ce3e4/image.png\"></p>\n<p><img src=\"https://velog.velcdn.com/images/nsunny0908/post/c0ab96d9-f764-41a0-9099-6f2bd9d59a90/image.png\"></p>\n<p>→ 이 과정을 <code class=\"language-text\">프레이밍</code>이라고 한다.</p>\n<h2>이더넷</h2>\n<ul>\n<li>LAN의 2계층에서 사용되는 프로토콜 (규칙)</li>\n<li>고유의 주소를 이용해 데이터를 주고받을 수 있도록 한다.</li>\n<li>주소는 데이터 전송 방법에 따라 3가지 종류가 있다.</li>\n</ul>\n<h3>유니캐스트</h3>\n<ul>\n<li>1:1 통신</li>\n<li>가장 일반적이다.</li>\n<li>각각의 기기는 유니캐스트의 주소를 반드시 하나 갖고 있다.</li>\n<li>유니캐스트의 주소는 유일해야한다.</li>\n</ul>\n<h3>브로드캐스트</h3>\n<ul>\n<li>세그먼트 내의 모든 기기에게 메세지를 보내는 데이터 통신</li>\n</ul>\n<h3>멀티캐스트</h3>\n<ul>\n<li>1:N</li>\n<li>같은 주소를 가진 기기가 여러개 있을 수 있다.</li>\n</ul>\n<p>각각의 기기는 유니캐스트의 주소를 반드시 하나 갖고있다.<br>\n반면에 멀티캐스트는 같은 주소를 가진 기기가 여러개 있어도 되는데, 멀티캐스트 주소는 ‘그룹'과 같은 취급을 하기 때문이다.<br>\n멀티캐스트가 1대 다수에게 메세지를 보내는 주소라고 했으니까, 굳이 각각 기기의 유니캐스트에게 보낼 필요 없이, 여러개의 기기를 아우르는 주소의 그룹에게 보내면 되는 것!</p>\n<p>그러니까, 멀티캐스트의 그룹에 속한 기기는 자신의 유니캐스트 주소 1개와 멀티캐스트 주소 이렇게 총 2개의 주소를 갖게 된다.</p>\n<p>예를 들자면, A라는 회사 개발팀 소속 kim에게 편지를 보내는 상황이 있다고 가정해보자.<br>\n수신처를 kim이라고 하면 유니캐스트로 수신을 하게 되는거고, A회사의 개발팀 으로 수신처를 정하게 되면 멀티캐스트로 수신하게 되는 것이다.</p>\n<h2>MAC주소</h2>\n<ul>\n<li>인터페이스에 지정된 고정 주소</li>\n</ul>\n<h2>이더넷은 어떻게 데이터를 송신할까?</h2>\n<h3>신호</h3>\n<ul>\n<li>허브로 연결되어 있는 컴퓨터는 같은 충돌 도메인에 있기 때문에 충돌이 발생한다.</li>\n<li>이더넷에서는 수신한 수신처의 MAC주소를 보고 해당 MAC주소가 아닌 다른 프레임은 다 파기하게 된다.</li>\n<li>그렇기 때문에 주소라는건 수신처가 자기인지 아닌지를 체크하기 위해서 있다고 할 수 있다.</li>\n</ul>\n<p>그렇다면 멀티캐스트랑 브로드캐스트는 그룹으로 묶인 주소를 가지고 있을텐데 이 경우에는 어떻게 판단하게 될까?</p>\n<p>멀티캐스트는 주소에 그룹의 번호가 들어있기 때문에 자신이 그 그룹의 소속되어있다면 수신하고 그 외의 경우는 파기하게 되고, 브로드캐스트는 어차피 전체 수신이때문에 반드시 수신하게 된다.</p>\n<h3>충돌</h3>\n<ul>\n<li>이더넷에서는 신호가 겹쳐서 충돌이 일어나지 않게 하는데 이를 위해서 CSMA/CD 라는 액세스 제어를 시행한다.</li>\n</ul>\n<h3>CSMA/CD</h3>\n<ul>\n<li>Carrier Sense(CS) : 송신자가 현재 회선에 신호가 흐르는지 탐지해서 누군가 송신중이라면 송신하지 않는다.</li>\n<li>Multiple Access(MA) : 아무도 송신하고 있지 않아 안전할 경우 송신을 허용한다.</li>\n<li>Collision Detection(CD) : 그다음 충돌을 탐지해 충돌이 일어나면 다시 재수행한다.</li>\n</ul>\n<p>→ 하지만 타이밍을 겹치지 않게 엇갈리게 해줄 뿐, 충돌을 모두 막아줄 수 없다.</p>\n<h2>스위치</h2>\n<ul>\n<li>허브에 여러가지 기능을 추가</li>\n<li>신호가 지나는 길을 나누는 방법을 사용해 충돌을 막아주는 기기\n(허브는 충돌이 발생하지 않도록 하기 위해서 신호를 보내는 타이밍을 겹치지 않게 엇갈리게 한다. 그런데 이 방법은 충돌을 모두 막아줄수가 없다. 우연치않게 타이밍이 겹치게 되면 충돌이 일어나기 때문이다.)</li>\n</ul>\n<h3>MAC 주소 테이블</h3>\n<ul>\n<li>포트에 연결되어있는 컴퓨터의 MAC주소를 기억하고 데이터베이스로 갖고 있다.</li>\n</ul>\n<h3>스위치가 MAC 주소 테이블을 작성하는 과정</h3>\n<ul>\n<li>통신을 하기 전까지는 MAC 주소 테이블은 비어 있다.</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/nsunny0908/post/72150b11-a9e2-4a2d-9462-b6555ab62e9d/image.png\"></p>\n<ul>\n<li>컴퓨터 1이 컴퓨터 3으로 데이터를 전송했을 때 데이터는 스위치를 거치면서 MAC 주소 테이블에 컴퓨터1의 맥주소가 추가된다.</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/nsunny0908/post/954a35bd-47f1-4562-b7de-cdfe33bed9e1/image.png\"></p>\n<ul>\n<li>컴퓨터 3으로 데이터를 보내야하는데 목적지의 MAC 주소를 모르기 때문에 플러딩이 발생한다.</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/nsunny0908/post/dd0cf92b-7510-4608-a59c-7c5c60a8a0e2/image.png\"></p>\n<ul>\n<li>목적지의 MAC주소를 아는 경우, 목적지에만 데이터를 전송하고 나머지 컴퓨터에는 데이터를 전송하지 않는다.</li>\n<li>수신처가 다른 프레임이 동시에 스위치에 도착하게 되어도 충돌은 발생하지 않게 된다.</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/nsunny0908/post/63772d61-d984-4e91-bde8-ed05de40331b/image.png\"></p>\n<p>그런데 만약에 수신처가 같은 프레임이 동시에 도달한 경우에는 어떻게 될까?<br>\n여기서 버퍼링이라는 개념이 나오게 된다.</p>\n<h2>버퍼</h2>\n<ul>\n<li>일시적으로 데이터를 기록해 둘 수 있는 메모리</li>\n<li>충돌할 것 같은 프레임을 버퍼에 일시적으로 저장</li>\n<li>먼저 보냈던 프레임의 송신이 끝나면 저장해뒀던 프레임을 송신한다. (임시피난소 느낌)</li>\n<li>용량이 제한되어 있다.</li>\n<li>특정한 규격을 사용해 버퍼가 부족할 것 같다고 판단되면 백 프레셔 등과 같은 규격을 사용해 송신을 중지한다.</li>\n</ul>\n<h2>버퍼링</h2>\n<ul>\n<li>버퍼(Buffer)를 사용한 처리를 실행하는 것</li>\n<li>먼저 보냈던 프레임의 송신이 끝나면 저장해뒀던 프레임을 송신하는 것</li>\n</ul>\n<h2>전이중 통신</h2>\n<ul>\n<li>송신과 수신을 동시에 할 수 있는 방식</li>\n<li>↔ CSMA/CD : 반이중 통신</li>\n</ul>\n<h2>전이중 이더넷</h2>\n<ul>\n<li>스위치는 전이중 통신이기 때문에 충돌을 염려할 필요가 없다. -> CSMA/CD를 사용할 필요가 없다.</li>\n<li>스위치를 사용해 전이중 통신을 하는 것</li>\n</ul>\n<h2>📝 정리</h2>\n<ol>\n<li>데이터링크 레이어는 ‘데이터를 어떻게 송수신할건지'를 생각하고 ‘규칙을 정하는’ 역할을 하는 계층이다.</li>\n<li>2계층의 이더넷은 고유의 주소를 이용해 데이터를 주고받을 수 있도록 한다.</li>\n<li>스위치는 허브와 달리 MAC 주소 테이블을 이용해 수신처에 해당하는 데이터만 전송할 수 있다.</li>\n</ol>","frontmatter":{"title":"OSI 7계층 중 2계층에 대해서 알아보자","date":"July 20, 2022"},"fields":{"slug":"/contents/posts/2022-07-20/","readingTime":{"minutes":11.11}}},"seriesList":{"edges":[{"node":{"id":"5267d72c-500b-59e9-9927-51ccdcf24b4a","fields":{"slug":"/contents/posts/2020-12-24/"},"frontmatter":{"title":"사진학도가 개발자가 된 이유"}}},{"node":{"id":"7a575c97-2286-5eb3-9a4e-df5412bfb335","fields":{"slug":"/contents/posts/2021-05-10/"},"frontmatter":{"title":"Intersection Observer API를 활용한 무한스크롤"}}},{"node":{"id":"0f295bb2-6a3c-511b-99d3-3d903307287d","fields":{"slug":"/contents/posts/2021-05-17/"},"frontmatter":{"title":"기술을 할 것인가, 예술을 할 것인가"}}},{"node":{"id":"9f0c0170-6efd-5ba0-b3b2-7130bedea7a0","fields":{"slug":"/contents/posts/2021-06-13/"},"frontmatter":{"title":"코딩 부트캠프와 좋은 개발자"}}},{"node":{"id":"3809cc24-7495-5555-925d-dc49258ffc52","fields":{"slug":"/contents/posts/2021-07-04/"},"frontmatter":{"title":"Prototype"}}},{"node":{"id":"ca0cb7cb-a3fe-525d-a38c-6cbd1852bd1d","fields":{"slug":"/contents/posts/2021-08-11/"},"frontmatter":{"title":"null 병합 연산자(nullish coalescing operator)"}}},{"node":{"id":"5e2b28f0-928d-5111-af17-8be7fbe9ec39","fields":{"slug":"/contents/posts/2021-08-12/"},"frontmatter":{"title":"\"함수 컴포넌트\"와 \"함수형 컴포넌트\"가 같은 말이라고 생각하시나요?"}}},{"node":{"id":"80af794d-6d8b-57a1-a2d1-64b3e3b98fa7","fields":{"slug":"/contents/posts/2021-08-16/"},"frontmatter":{"title":"React Context Api"}}},{"node":{"id":"6ce9e47c-23b4-5026-bed6-116351eb8aee","fields":{"slug":"/contents/posts/2021-08-21/"},"frontmatter":{"title":"React Portal"}}},{"node":{"id":"88cdf508-0abb-5014-8d70-e65d35c6d884","fields":{"slug":"/contents/posts/2021-08-22/"},"frontmatter":{"title":"제어 컴포넌트와 비제어 컴포넌트"}}},{"node":{"id":"0d93f1f5-2ccc-54b6-b943-7179687ac266","fields":{"slug":"/contents/posts/2021-08-30/"},"frontmatter":{"title":"TDZ (Temporal Dead Zone)"}}},{"node":{"id":"457d0b1b-3d90-5eea-a66f-8587373ab7c6","fields":{"slug":"/contents/posts/2021-09-04/"},"frontmatter":{"title":"VAC 패턴"}}},{"node":{"id":"b0b1c6d8-47d0-5edf-9261-25d3a5a75ad2","fields":{"slug":"/contents/posts/2021-09-09/"},"frontmatter":{"title":"Typescript Alias 설정시 마주친 오류"}}},{"node":{"id":"c2550142-36f4-5398-a554-702b8fa1b6b8","fields":{"slug":"/contents/posts/2021-10-05/"},"frontmatter":{"title":"patch-package로 외부 라이브러리 수정해서 사용하기"}}},{"node":{"id":"36da5bac-6acc-5daa-b307-4a9fdc74542f","fields":{"slug":"/contents/posts/2021-11-25/"},"frontmatter":{"title":"Custom hook vs Function"}}},{"node":{"id":"2a55cc9e-c79c-5a4d-ac53-a0d36cc69597","fields":{"slug":"/contents/posts/2021-12-19/"},"frontmatter":{"title":"NPM"}}},{"node":{"id":"6d5384bb-c04f-5cc7-945c-5aea5380bb94","fields":{"slug":"/contents/posts/2021-12-31/"},"frontmatter":{"title":"2021년 회고"}}},{"node":{"id":"745a2241-d9b5-5ce0-b6fd-f2a66699554d","fields":{"slug":"/contents/posts/2022-01-05/"},"frontmatter":{"title":":focus-within"}}},{"node":{"id":"b794f451-f15c-5011-8dba-34a5b533b144","fields":{"slug":"/contents/posts/2022-02-28/"},"frontmatter":{"title":"div에서 placeholder 사용하기 (styled-component)"}}},{"node":{"id":"7c078298-d430-54a2-a954-63a6687c7328","fields":{"slug":"/contents/posts/2022-03-13/"},"frontmatter":{"title":"Tooltip component 트러블 슈팅"}}},{"node":{"id":"f1e4e298-5cae-5a57-8798-17ababf157e0","fields":{"slug":"/contents/posts/2022-04-01/"},"frontmatter":{"title":"OSI 7계층 중 1계층에 대해서 알아보자"}}},{"node":{"id":"279cb68d-a1a3-5ee4-b743-784d2bf365c5","fields":{"slug":"/contents/posts/2022-05-22/"},"frontmatter":{"title":"프론트앤드에서의 테스트 (나에겐 너무나 멀고 힘든 테스트코드 짜기..)"}}},{"node":{"id":"83ff9034-42a0-5267-bc2b-d710f2446cff","fields":{"slug":"/contents/posts/2022-06-05/"},"frontmatter":{"title":"debounce 트러블 슈팅"}}},{"node":{"id":"796731f6-1035-5bb8-ac76-467aae3fa171","fields":{"slug":"/contents/posts/2022-06-11/"},"frontmatter":{"title":"Object Delete"}}},{"node":{"id":"bbb421e5-8831-5038-a552-96243600d346","fields":{"slug":"/contents/posts/2022-06-25/"},"frontmatter":{"title":"Modal esc 관련 트러블 슈팅"}}},{"node":{"id":"df7ea411-5375-56e2-8ce9-4f86bb631af7","fields":{"slug":"/contents/posts/2022-07-20/"},"frontmatter":{"title":"OSI 7계층 중 2계층에 대해서 알아보자"}}},{"node":{"id":"bd139eae-9fe0-53cd-9205-95f18d33e90d","fields":{"slug":"/contents/posts/2022-08-17/"},"frontmatter":{"title":"페이지네이션 검색 관련 트러블슈팅"}}},{"node":{"id":"a8bfc1a9-ef8f-554f-8caf-5c17a027f52a","fields":{"slug":"/contents/posts/2022-09-10/"},"frontmatter":{"title":"이제 deep copy할 때 structuredClone을 씁시다."}}},{"node":{"id":"0cabe0ee-d57f-5cc9-8402-1a960f86eed7","fields":{"slug":"/contents/posts/2022-09-12/"},"frontmatter":{"title":"javascript class와 private 속성"}}},{"node":{"id":"3a533e42-a168-5aad-bb6b-0bee817a94cd","fields":{"slug":"/contents/posts/2022-09-24/"},"frontmatter":{"title":"TypeScript의 Soundness와 Type Assertion (as 떡칠하지 말자..)"}}},{"node":{"id":"9f1a0f31-42b4-5c43-8baa-c5973a1a5281","fields":{"slug":"/contents/posts/2022-09-28/"},"frontmatter":{"title":"어쩐지 yarn으로 패키지 설치할 때 오류가 났다.."}}},{"node":{"id":"74180524-c983-5af9-810b-e70418f145a5","fields":{"slug":"/contents/posts/2022-10-06/"},"frontmatter":{"title":"storybook addon 안보일때"}}},{"node":{"id":"a9317839-66e0-5734-a125-5266ac700f9f","fields":{"slug":"/contents/posts/2022-12-31/"},"frontmatter":{"title":"2022년 회고"}}},{"node":{"id":"e0593ebb-38b6-5d5b-bd37-63a6740ea2e8","fields":{"slug":"/contents/posts/2023-07-05/"},"frontmatter":{"title":"get image api 오류 트러블 슈팅"}}},{"node":{"id":"a5ffa0e0-ac0f-592c-a606-ef5545b8d5f5","fields":{"slug":"/contents/posts/2023-08-05/"},"frontmatter":{"title":"The Progressive JavaScript Framework"}}},{"node":{"id":"dba241d0-3594-5a1d-a854-be8184071124","fields":{"slug":"/contents/posts/2023-08-13/"},"frontmatter":{"title":"why can’t use window in vue template?"}}},{"node":{"id":"3bfdd15b-b1ae-57eb-98d8-ac40ffe55a63","fields":{"slug":"/contents/posts/2023-08-25/"},"frontmatter":{"title":"처음 남의 코드를 받으면 뭘 해야할까?"}}},{"node":{"id":"f399c871-2d22-5b62-ae86-75e0aa456d6d","fields":{"slug":"/contents/posts/2023-08-27/"},"frontmatter":{"title":"동물의 숲 짤 생성기를 만들었다"}}},{"node":{"id":"a78e398b-f8c7-56c1-a2c0-deedd720557b","fields":{"slug":"/contents/posts/2023-09-17/"},"frontmatter":{"title":"신뢰할 수 없는 코드를 쓰면서 불변성 지키기"}}},{"node":{"id":"a5b16fda-7eb6-5089-a91c-9231b9dd28d0","fields":{"slug":"/contents/posts/2023-10-01/"},"frontmatter":{"title":"mac에 rocky linux 설치하기"}}},{"node":{"id":"87297bfb-cf0a-5b5e-937c-f2aaa8295258","fields":{"slug":"/contents/posts/2023-10-09/"},"frontmatter":{"title":"nx로 모노레포 구축하기 (삽질기록)"}}}]},"previous":{"fields":{"slug":"/contents/posts/2022-06-25/"},"frontmatter":{"title":"Modal esc 관련 트러블 슈팅"}},"next":{"fields":{"slug":"/contents/posts/2022-08-17/"},"frontmatter":{"title":"페이지네이션 검색 관련 트러블슈팅"}}},"pageContext":{"id":"df7ea411-5375-56e2-8ce9-4f86bb631af7","series":null,"previousPostId":"bbb421e5-8831-5038-a552-96243600d346","nextPostId":"bd139eae-9fe0-53cd-9205-95f18d33e90d"}},"staticQueryHashes":[],"slicesMap":{}}